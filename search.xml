<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建hexo博客</title>
    <url>/2022/08/29/blog_built/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><font size=3>参考了很多资料：b站，github，别人的博客<font><br><a href="https://www.cnblogs.com/huanhao/p/hexobase.html">参考最多的博客</a><br><a href="https://argvchs.netlify.app/">我主题作者的博客</a><br><a href="https://github.com/argvchs/hexo-theme-particlex">主题获取</a></p>
<hr>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul>
<li><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3></li>
</ul>
<blockquote>
<p><a href="http://nodejs.cn/download/">node.js获取</a>   </p>
<p><mark>记得添加环境变量再next</mark>  </p>
</blockquote>
<ul>
<li><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3></li>
</ul>
<blockquote>
<p><a href="https://git-scm.com/">git获取</a><br>一路next就行<br><em><strong>验证是否安装成功：</strong></em><br>验证git: 桌面右键有git bash<br><img src="https://i.loli.net/2020/02/29/s1YhxtEILOlk4Xz.png" alt="git">   </p>
</blockquote>
<ul>
<li><h3 id="验证node-js-点击git-bash依次执行命令"><a href="#验证node-js-点击git-bash依次执行命令" class="headerlink" title="验证node.js:  点击git bash依次执行命令"></a>验证node.js:  点击git bash依次执行命令</h3></li>
</ul>
<pre><code class="bash">$ node -v
$ npm -v
</code></pre>
<p><em><strong>输出版本号就算成功</strong></em>   </p>
<ul>
<li><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3></li>
</ul>
<blockquote>
<p>git bash中执行：   </p>
</blockquote>
<pre><code class="bash">    $ npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<blockquote>
<p>检查是否安装完成：</p>
</blockquote>
<pre><code class="bash">$ cnpm -v
</code></pre>
<h2 id="安装hexo并初始化"><a href="#安装hexo并初始化" class="headerlink" title="安装hexo并初始化"></a>安装hexo并初始化</h2><ul>
<li><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3></li>
</ul>
<pre><code class="bash"> $ cnpm install hexo-cli -g
</code></pre>
<ul>
<li><h3 id="创建blog文件夹并在当前目录打开git-bash"><a href="#创建blog文件夹并在当前目录打开git-bash" class="headerlink" title="创建blog文件夹并在当前目录打开git bash"></a>创建blog文件夹并在当前目录打开git bash</h3></li>
</ul>
<blockquote>
<p>依次执行命令：</p>
</blockquote>
<pre><code class="bash">$ hexo init
$ cnpm install
</code></pre>
<blockquote>
<p>这时可以在本地浏览我们的博客了</p>
</blockquote>
<pre><code class="bash">$ hexo s
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kjhuanhao/blogcdn/img/Snipaste_2020-02-29_09-31-47.jmi628mj35e.png" alt="blog_local">   </p>
<h2 id="可以更换主题然后配置文件啦！"><a href="#可以更换主题然后配置文件啦！" class="headerlink" title="可以更换主题然后配置文件啦！"></a>可以更换主题然后配置文件啦！</h2><blockquote>
<h3 id="hexo的主题地址："><a href="#hexo的主题地址：" class="headerlink" title="hexo的主题地址："></a>hexo的主题地址：</h3><p><a href="https://hexo.io/themes/">hexo</a>    </p>
</blockquote>
<h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><blockquote>
<p>打开主题地址：点击 Clone or download<br><img src="https://cdn.jsdelivr.net/gh/kjhuanhao/blogcdn/img/Snipaste_2020-02-29_09-46-02.gnmyl5b7s2.png" alt="clone"><br>在blog文件夹中打开git bash<br>执行命令：</p>
</blockquote>
<pre><code class="bash">git clone 复制的地址 themes/主题名字
</code></pre>
<h2 id="接着可以修改站点配置文件什么的"><a href="#接着可以修改站点配置文件什么的" class="headerlink" title="接着可以修改站点配置文件什么的"></a>接着可以修改站点配置文件什么的</h2><h2 id="部署到coding-或者-github"><a href="#部署到coding-或者-github" class="headerlink" title="部署到coding 或者 github"></a>部署到coding 或者 github</h2><blockquote>
<p>可以参考我推荐的别人的blog   </p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/27/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>不同数据方法的excel实践</title>
    <url>/2022/09/03/excel%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何用excel来进行描述性分析"><a href="#如何用excel来进行描述性分析" class="headerlink" title="如何用excel来进行描述性分析"></a>如何用excel来进行描述性分析</h1><ul>
<li>平均值：</li>
</ul>
<pre><code class="excel"> = average()  
</code></pre>
<ul>
<li>标准差：</li>
</ul>
<pre><code class="excel">   = stdev.p()   
</code></pre>
<ul>
<li>极差：</li>
</ul>
<pre><code class="excel"> = max()-min()  
</code></pre>
<ul>
<li>直方图：   <blockquote>
<p><img src="/../imgs/ex.png" alt="exc"><br>click “插入” -&gt; “推荐图表”<br><img src="/../imgs/excl.png" alt="excl">  </p>
</blockquote>
</li>
<li>折线图：  <blockquote>
<p><img src="/../imgs/zhe.png" alt="zhe">  </p>
</blockquote>
</li>
<li>气泡图：(xy散点图变种)：适用于三个变量   <blockquote>
<p><img src="/../imgs/pao.png" alt="pao"></p>
</blockquote>
</li>
</ul>
<h1 id="如何利用excel来进行诊断性分析"><a href="#如何利用excel来进行诊断性分析" class="headerlink" title="如何利用excel来进行诊断性分析"></a>如何利用excel来进行诊断性分析</h1><h2 id="关联分析："><a href="#关联分析：" class="headerlink" title="关联分析："></a>关联分析：</h2><pre><code class="excel">  = peason(...  ...)   //皮尔斯系数
 or = correl(... ...)  //相关系数
</code></pre>
<h1 id="利用excel来进行预测性分析"><a href="#利用excel来进行预测性分析" class="headerlink" title="利用excel来进行预测性分析"></a>利用excel来进行预测性分析</h1><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><blockquote>
<ul>
<li>excel 中添加插件  </li>
<li>“数据”-&gt;”数据分析”   </li>
<li>解读结果</li>
</ul>
</blockquote>
<h2 id="仿真模拟"><a href="#仿真模拟" class="headerlink" title="仿真模拟"></a>仿真模拟</h2><h1 id="图标类型的选择"><a href="#图标类型的选择" class="headerlink" title="图标类型的选择"></a>图标类型的选择</h1><blockquote>
<ol>
<li>利用柱状图比较数据大小</li>
<li>利用散点图表示数据关系</li>
<li>利用气泡图观察多指标间的关系 </li>
<li>利用折线图观察时间序列数据  </li>
<li>利用雷达图展现多维数据  </li>
<li>利用漏斗图分析数据转化</li>
</ol>
</blockquote>
<h1 id="图标优化"><a href="#图标优化" class="headerlink" title="图标优化"></a>图标优化</h1><blockquote>
<ol>
<li>坐标轴范围要包含数据本身  </li>
<li>是用红色标注强调内容 </li>
<li>刻度线数据标签等细节优化<br><img src="/../imgs/youhua.png" alt="youhua"></li>
</ol>
</blockquote>
<h1 id="多维数据的筛选和应用"><a href="#多维数据的筛选和应用" class="headerlink" title="多维数据的筛选和应用"></a>多维数据的筛选和应用</h1><blockquote>
<ul>
<li>一维数据只有单一属性，直观简洁，信息量有限</li>
<li>二维数据被用于比较和分析两个不同属性的关联度上  </li>
<li>三维数据被用于分析多属性对象的，优点是信息量大，结论清晰，缺点是对于细节仍无法面面俱到</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>excel实践</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 博客美化</title>
    <url>/2022/08/29/hexo-%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><font face="GB18030 Bitmap">新生要军训，好几天都不能跑步，崩溃了。。 </font>   </p>
<img src=https://w.wallhaven.cc/full/72/wallhaven-72yqlv.png width = "300" height = "200" alt="我" align=center />   

<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/69211731">参考资料</a></p>
</li>
<li><h2 id="添加看板娘（我的是看板狗hahaha"><a href="#添加看板娘（我的是看板狗hahaha" class="headerlink" title="添加看板娘（我的是看板狗hahaha)"></a>添加看板娘（我的是看板狗hahaha)</h2></li>
</ul>
<blockquote>
<p><strong>在git bash上获取live2d：</strong>   </p>
</blockquote>
<pre><code class="bash">$ npm install --save hexo-helper-live2d
</code></pre>
<blockquote>
<p>输入以下命令，下载相应的模型，将 packagename 更换成型名称即可，更多模型选择请<a href="https://github.com/xiazeyu/live2d-widget-models">点击此处</a>，各个模型的预览请访问<a href="https://huaji8.top/post/live2d-plugin-2.0/">原作者的博客</a></p>
</blockquote>
<pre><code class="bash">$ npm install packagename
</code></pre>
<blockquote>
<p>打开站点目录下的 _config.yml 文件，添加如下代码：</p>
</blockquote>
<pre><code class="yml">live2d:
    enable: true
    scriptFrom: local
    model: 
        use: live2d-widget-model-haruto #模型选择
    display: 
        position: right  #模型位置
        width: 150       #模型宽度
        height: 300      #模型高度
    mobile: 
        show: false      #是否在手机端显示
</code></pre>
<blockquote>
<p>设置好过后我们就拥有了一个卡通人物 （我在想是否能搞个米蒂的模型呢hahahaha）</p>
</blockquote>
<ul>
<li><h2 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h2></li>
</ul>
<blockquote>
<p><strong>效果烟花爆炸：</strong><br>在 \themes\主题\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码：</p>
</blockquote>
<pre><code class="js">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;
</code></pre>
<blockquote>
<p>然后在 \themes\主题\layout\layout.ejs 文件中写入以下代码：</p>
</blockquote>
<pre><code class="ejs">&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; 
&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; 
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li><h2 id="添加背景音乐"><a href="#添加背景音乐" class="headerlink" title="添加背景音乐"></a>添加背景音乐</h2></li>
</ul>
<blockquote>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote>
<p>打开网页版<a href="https://music.163.com/">网易云音乐</a>，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码  </p>
</blockquote>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-19a363752b9ac44ca80824b81e86233d_1440w.jpg" alt="easenet">   </p>
<blockquote>
<blockquote>
<p>然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \themes\主题\layout\left.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto&#x3D;1 表示打开网页自动播放音乐，auto&#x3D;0 表示关闭自动播放音乐    </p>
</blockquote>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote>
<p>在layout.ejs中body标签加入以下：   </p>
</blockquote>
</blockquote>
<pre><code class="html"> &lt;!--音乐--&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;
  &lt;div id=&quot;player&quot; class=&quot;aplayer aplayer-withlist aplayer-fixed&quot; data-id=&quot;3025663508&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-order=&quot;random&quot; data-fixed=&quot;true&quot; data-listfolded=&quot;true&quot; data-theme=&quot;#2D8CF0&quot;&gt;&lt;/div&gt;  
</code></pre>
<blockquote>
<blockquote>
<p>可以自行修改参数   </p>
<h2 id="重要优化"><a href="#重要优化" class="headerlink" title="重要优化"></a>重要优化</h2><p>实现aplayer嵌入效果（像我一样）    </p>
</blockquote>
</blockquote>
<pre><code class="css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body &#123;
    left: -66px !important
&#125;

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover &#123;
    left: 0 !important
&#125;
</code></pre>
<blockquote>
<blockquote>
<p>layout.ejs文件中添加：</p>
</blockquote>
</blockquote>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/aplayer.css&quot;/&gt;
</code></pre>
<ul>
<li><h2 id="流星背景特效"><a href="#流星背景特效" class="headerlink" title="流星背景特效"></a>流星背景特效</h2></li>
</ul>
<blockquote>
<p>使用：</p>
</blockquote>
<pre><code class="layout.ejs">&lt;canvas
    id=&quot;background&quot;
    style=&quot;position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1&quot;
&gt;&lt;/canvas&gt;
&lt;script src=&quot;/js/background.js&quot;&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<p>下载：<a href="https://argvchs.netlify.app/js/background.js">background.js</a></p>
</blockquote>
<ul>
<li><h2 id="鼠标指针特效"><a href="#鼠标指针特效" class="headerlink" title="鼠标指针特效"></a>鼠标指针特效</h2></li>
</ul>
<blockquote>
<p>使用：</p>
</blockquote>
<pre><code class="layout.ejs">&lt;div id=&quot;cursor&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;/css/cursor.css&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/cursor.js&quot;&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<p>下载：</p>
<p><a href="https://argvchs.netlify.app/assets/cursor.css">cursor.css</a><br><a href="https://argvchs.netlify.app/js/cursor.js">cursor.js</a></p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title>knn算法</title>
    <url>/2022/09/12/knn%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KNN算法——k-nearestneighbor"><a href="#KNN算法——k-nearestneighbor" class="headerlink" title="KNN算法——k-nearestneighbor"></a>KNN算法——k-nearestneighbor</h1><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><blockquote>
<p>找到k个与新数据最近的样本，取样本中最多的一个类别作为新数据的类别  </p>
</blockquote>
<h2 id="对于距离"><a href="#对于距离" class="headerlink" title="对于距离"></a>对于距离</h2><ul>
<li>欧式距离：两点之间连线</li>
</ul>
<h2 id="算法优点"><a href="#算法优点" class="headerlink" title="算法优点"></a>算法优点</h2><ul>
<li>简单容易实现  </li>
<li>对于边界不规则的数据效果最好   （对比于线性划分）</li>
</ul>
<h2 id="算法缺点"><a href="#算法缺点" class="headerlink" title="算法缺点"></a>算法缺点</h2><ul>
<li>只适用于小数据集   </li>
<li>数据不平衡   </li>
<li>必须进行数据标准化 </li>
<li>不适用于特征维度太多的数据</li>
</ul>
<h2 id="k值选取"><a href="#k值选取" class="headerlink" title="k值选取"></a>k值选取</h2><ul>
<li>k越小容易过拟合  </li>
<li>k越大容易欠拟合   </li>
<li>合适的k值凭借经验和效果尝试</li>
</ul>
<h1 id="利用鸢尾花数据作为例子"><a href="#利用鸢尾花数据作为例子" class="headerlink" title="利用鸢尾花数据作为例子"></a>利用鸢尾花数据作为例子</h1><h2 id="导入所需要的依赖库"><a href="#导入所需要的依赖库" class="headerlink" title="导入所需要的依赖库"></a>导入所需要的依赖库</h2><pre><code class="python">#导入所需要依赖库
from sklearn import datasets #sklearn的数据集
from sklearn.neighbors import KNeighborsClassifier  #sklearn模块的knn类
import numpy as np #矩阵运算库numpy
#设置随机种子 可以保证我们每次产生的随机数是一样的
np.random.seed(0)
</code></pre>
<h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><pre><code class="python">#关于鸢尾花的数据集
iris = datasets.load_iris() #获取鸢尾花数据集
iris_x = iris.data #数据部分
iris_y = iris.target #类别部分
</code></pre>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><pre><code class="python">#从150条数据中选择140条作为训练集，10条作为测试集。permutation接受一个数作为参数（这里为数据集长度150），产生一个0-149的乱序一维数组
randomarr = np.random.permutation(len(iris_x))
iris_x_train = iris_x[randomarr[:-10]] #训练集数据
iris_y_train = iris_y[randomarr[:-10]] #训练集标签
iris_x_test = iris_x[randomarr[-10:]] #测试集数据
iris_y_test = iris_y[randomarr[-10:]] #测试集标签
</code></pre>
<h2 id="定义knn分类器类并调用方法进行学习"><a href="#定义knn分类器类并调用方法进行学习" class="headerlink" title="定义knn分类器类并调用方法进行学习"></a>定义knn分类器类并调用方法进行学习</h2><pre><code class="python">#定义一个knn分类器对象
knn = KNeighborsClassifier()
#调用该对象的训练方法，接受两个参数 ：训练数据集及其类别标签
knn.fit(iris_x_train,iris_y_train)
#调用预测方法，主要接受一个参数：测试数据集
iris_y_predict = knn.predict(iris_x_test)
</code></pre>
<h2 id="计算测试样本概率值"><a href="#计算测试样本概率值" class="headerlink" title="计算测试样本概率值"></a>计算测试样本概率值</h2><pre><code class="python">#计算测试样本预测的概率值 这里我们没有用概率值，但是实际工作中可能会参考概率值来进行最后结果的筛选
# ，而不是直接使用给出的预测标签
probility = knn.predict_proba(iris_x_test)
</code></pre>
<h2 id="k-x3D-5，对测试集测试输出结果"><a href="#k-x3D-5，对测试集测试输出结果" class="headerlink" title="k&#x3D;5，对测试集测试输出结果"></a>k&#x3D;5，对测试集测试输出结果</h2><pre><code class="python">#计算与最后一个测试样本距离最近的五个点，返回的是这些样本的序号组成的数组
neihborpoint = knn.kneighbors([iris_x_test[-1]],5)

#调用该对象的打分方法，计算出准确率
score = knn.score(iris_x_test,iris_y_test,sample_weight = None)

#输出测试结果
print(&#39;iris_y_predict=&#39;)
print(iris_y_predict)

#输出正确结果来比对
print(&#39;iris_y_test = &#39;)
print(iris_y_test)

#输出准确率
print(&#39;accuracy:&#39;,score)
</code></pre>
<hr>
<h1 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h1><p><img src="/../imgs/result.png" alt="res"></p>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>KNN算法</tag>
        <tag>分类问题</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas python编程</title>
    <url>/2022/09/04/pandas-python%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建表，保存表，设置索引"><a href="#创建表，保存表，设置索引" class="headerlink" title="创建表，保存表，设置索引"></a>创建表，保存表，设置索引</h2><pre><code class="python">import pandas as pd
df = pd.DataFrame(&#123;&#39;id&#39;:[1,2,3],&#39;name&#39;:[&#39;tim&#39;,&#39;viotor&#39;,&#39;nick&#39;]&#125;)   #创建表
df = df.set_index(&#39;id&#39;)   #将id设置为索引
#更改到本地
df.set_index(&#39;id&#39;,inplace=True)
df.to_excel(&#39;d:/code/temp/output.xlsx&#39;)   #保存到
print(&#39;done!&#39;)
</code></pre>
<h2 id="读取表"><a href="#读取表" class="headerlink" title="读取表"></a>读取表</h2><pre><code class="python">#数据读取
people =pd.read_excel(&#39;d:/code/temp/output.xlsx&#39;) #读取excle文件
#知道哪一行是index时
people =pd.read_excel(&#39;d:/code/temp/output.xlsx&#39;,index_col=&#39;id&#39;) #读取excle文件
print(people.shape)  #读取多少行多少列
print(people.columns)  #元素名（列）
print(people.head(3))  #读取文件前面信息（默认5行）
print(people.tail(3)) #读取尾部
# 当数据信息头部存在垃圾信息时(自动跳离空行)  自定义头部开始下标
people =pd.read_excel(&#39;d:/code/temp/output.xlsx&#39;,header=1) #读取excle文件
#当数据没有header时
people =pd.read_excel(&#39;d:/code/temp/output.xlsx&#39;,header= None) #读取excle文件
#设置头部信息
people.columns=[&#39;id&#39;,&#39;type&#39;,&#39;title&#39; ]
</code></pre>
<h2 id="序列Series（表示表中一行或一列-只有填充进dataframe中才明确）"><a href="#序列Series（表示表中一行或一列-只有填充进dataframe中才明确）" class="headerlink" title="序列Series（表示表中一行或一列 只有填充进dataframe中才明确）"></a>序列Series（表示表中一行或一列 只有填充进dataframe中才明确）</h2><pre><code class="python">d = dict()
s1 = pd.Series()  #生成一个序列（具有data，name，index等属性）  类比字典
s2 = pd.Series(d)  #将字典转化为序列
</code></pre>
<h2 id="创建序列的另一个方法"><a href="#创建序列的另一个方法" class="headerlink" title="创建序列的另一个方法"></a>创建序列的另一个方法</h2><pre><code class="python">l1 = [100,200,300]
l2 = [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]
s1 = pd.Series(l1,index=l2)
</code></pre>
<h2 id="填充dataframe"><a href="#填充dataframe" class="headerlink" title="填充dataframe"></a>填充dataframe</h2><pre><code class="python">#序列填充dataframe
s1 = pd.Series([1,2,3],index=[1,2,3],name = &#39;A&#39;)
s2 = pd.Series([10,20,30],index=[1,2,3],name = &#39;B&#39;)
s3 = pd.Series([100,200,300],index=[1,2,3],name = &#39;C&#39;)
#以字典的方式填充入
df = pd.DataFrame(&#123;s1.name:s1,s2.name:s2,s3.name:s3&#125;)
</code></pre>
<pre><code class="python">#excle的自动填充功能
books= pd.read_excel(&#39;d:/code/temp/output.xlsx&#39;,skiprows=3,usecols=&quot;c:f&quot;,index_col=None)  #跳出空白行列
#利用循环自动填充
for i in books.index:
    books[&#39;id&#39;].at[i]=i+1   #类型为浮点类型 可以在读取时添加参数：dtype=&#123;‘id’:str&#125;来解决

# apply函数
books[&#39;listprice&#39;] = books[&#39;listprice&#39;].apply(lambda x: x+2)   #可以是函数，可以是lambda表达式
</code></pre>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code class="python">product.sort_values(by=[&#39;...&#39;,&#39;...&#39;],inplace = true, ascending=[false,...])   #inplace:在本表上操作  
</code></pre>
<h2 id="数据筛选"><a href="#数据筛选" class="headerlink" title="数据筛选"></a>数据筛选</h2><pre><code class="python">def age(a):
    return a&gt;=18 and a&lt;30
people = people.loc[people[&#39;age&#39;].apply(age)]
print(people)
</code></pre>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><ul>
<li>利用pandas绘图：</li>
</ul>
<pre><code class="python">import pandas as pd
import matplotlib.pyplot as plt

exa = pd.read_excel(&#39;D:/code/temp/exa.xlsx&#39;)
print(exa.head(1))

# bar
exa.plot.bar(x=&#39;user_id&#39;, y=&#39;click_article_id&#39;, color=&#39;pink&#39;, title=&#39;mytitle&#39;)  #利用的是pandas的绘图
plt.tight_layout()   #紧凑布局 标签能够完全显示
plt.show()  #显现图片
</code></pre>
<ul>
<li>利用matplotlib绘图:</li>
</ul>
<pre><code class="python">plt.bar(exa.user_id,exa.click_article_id,color=&#39;pink&#39;)
plt.tight_layout()   #紧凑布局 标签能够完全显示
plt.xticks(exa.user_id,rotation=&#39;90&#39;)   #旋转x轴标签
plt.xlabel(&#39;myxlabel&#39;) #设置x轴
plt.ylabel(&#39;myylabel&#39;) #设置y轴
plt.title(&#39;mytitle&#39;,fontsize=16) #设置图名  有fontweight属性=&#39;bold&#39;加粗字体
plt.show()  #显现图片  
</code></pre>
<blockquote>
<p>bar_example<br><img src="/../imgs/Figure_1.png" alt="figure">  </p>
</blockquote>
<ul>
<li>优化</li>
</ul>
<pre><code class="python">#分组柱状图   叠加柱状图增加stacked=true参数就行  同时.barh是将figure部分旋转
exa.plot.bar(x=&#39;user_id&#39;, y=[&#39;click_region&#39;,&#39;click_referrer_type&#39;], color=[&#39;pink&#39;,&#39;blue&#39;], title=&#39;mytitle&#39;)  #利用的是pandas的绘图
#优化数轴
ax = plt.gcal()
ax.set_xticklabels(exa[&#39;user_id&#39;], rotation=45, ha=&#39;right&#39;)
plt.tight_layout()
#优化图像
f = plt.gcf()
f.subpiots_adjust(left=0.2, buttom=0.42) #左边流出20% 底下流出42%
plt.show()
</code></pre>
<blockquote>
<p>example<br><img src="/../imgs/figure_2.png" alt="figure"></p>
</blockquote>
<h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><pre><code class="python">exa = pd.read_excel(&#39;D:/code/temp/output.xlsx&#39;)
print(exa.head(1))

#饼状图
exa[&#39;value1&#39;].plot.pie(fontsize=8,counterclock=False)
plt.title(&#39;mytitle&#39;,fontsize=16,fontweight=&#39;bold&#39;)
plt.ylabel(&#39;value1&#39;)
plt.show()
</code></pre>
<blockquote>
<p>example:<br><img src="/../imgs/Figure_3.png" alt="figure">  </p>
</blockquote>
<h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><pre><code class="python">exa.plot(y=[&#39;value1&#39;,&#39;value2&#39;,&#39;value3&#39;,&#39;value4&#39;,&#39;value5&#39;]) #.plot.area为叠加区域图
plt.title(&#39;mytitle&#39;,fontsize=16,fontweight=&#39;bold&#39;)
plt.ylabel(&#39;total_value&#39;,fontsize=8,fontweight=&#39;bold&#39;)
plt.xticks(exa.index) #修改x坐标
plt.show()
</code></pre>
<blockquote>
<p>example；<br><img src="/../imgs/Figure_4.png" alt="figure"></p>
</blockquote>
<h2 id="scatter散点图"><a href="#scatter散点图" class="headerlink" title="scatter散点图"></a>scatter散点图</h2><pre><code class="python">#散点图
exa.plot.scatter(x=&#39;id&#39;,y=&#39;value1&#39;)
plt.show()
</code></pre>
<p><img src="/../imgs/scatter.png" alt="scatter"></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><pre><code class="python">exa.value1.plot.hist(bins = 100) #默认桶很大
plt.xticks(range(0,max(exa.value1),10),fontsize=8,rotation=90) #调整步长
plt.show()
</code></pre>
<p><img src="/../imgs/hist2.png" alt="hist"></p>
<h2 id="密度图"><a href="#密度图" class="headerlink" title="密度图"></a>密度图</h2><pre><code class="python">#密度图
exa.value1.plot.kde() #kernal densitive 
plt.xticks(range(0,max(exa.value1),10),fontsize=8,rotation=90) #调整步长
plt.show()
</code></pre>
<p><img src="/../imgs/kde.png" alt="kde"></p>
<h2 id="每两列间的相关性"><a href="#每两列间的相关性" class="headerlink" title="每两列间的相关性"></a>每两列间的相关性</h2><pre><code class="python">#元素相关性
print(exa.corr())
</code></pre>
<h2 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h2><pre><code class="python">table = table1.marge(table2, how=&#39;left&#39;,on=&#39;id&#39;).fillna(0)   #how ... 左边元素全保留  na用0填充  或者用；left_on   right_on 的形式  再者用.join()自动联立
table.value=table.value.astype(int)  #替换数据类型
print(table)
</code></pre>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><pre><code class="python">#数据校验
def value_validation(row):
    try:
        assert 0&lt;=row.value1&lt;=50
    except:
        print(f&#39;#&#123;row.id&#125;\trow has an  invalid value &#123;row.value1&#125;&#39;)

    # if not 0&lt;=row.value1&lt;=100:
    #     print(...)

exa.apply(value_validation,axis=1)
</code></pre>
<h2 id="统计操作"><a href="#统计操作" class="headerlink" title="统计操作"></a>统计操作</h2><pre><code class="python">#统计操作
temp=exa[[&#39;value1&#39;,&#39;value2&#39;,&#39;value3&#39;]]  #抽取子集
# print(temp)
exa[&#39;row_sum&#39;] = temp.sum(axis=1)   #series类型  从左到右轴是1 从上到下轴是2 #求和
exa[&#39;row_mean&#39;] = temp.sum(axis=1)  #求平均值
print(exa)
</code></pre>
<h2 id="定位消除重复数据"><a href="#定位消除重复数据" class="headerlink" title="定位消除重复数据"></a>定位消除重复数据</h2><pre><code class="python">#定位消除重复数据
exa.drop_duplicates(subset= [&#39;...&#39;,&#39;...&#39;], inplace=True)  #基于...来消除重复行
#还有keep参数 =‘first’：保留一开始重复数据 =‘last’：保留最后数据
#找到重复数据
dupe = exa.duplicated(subset=&#39;...&#39;)  #显示重复关系
print(dupe.any())  #是否有重复数据
dupe = dupe[dupe==True]  #过滤后得到重复数据
print(exa.iloc[dupe.index])   #定位重复数据
</code></pre>
<h2 id="旋转表格"><a href="#旋转表格" class="headerlink" title="旋转表格"></a>旋转表格</h2><pre><code class="python">#旋转数据表
pd.option.display.max_columns = 999 #python显示更多元素
table = exa.transpose()
print(table)
</code></pre>
<h2 id="读取txt-csv-tsv文件"><a href="#读取txt-csv-tsv文件" class="headerlink" title="读取txt csv tsv文件"></a>读取txt csv tsv文件</h2><pre><code class="python">
exa  = pd.read_csv(&#39;... .csv&#39;,index_col=&#39;..&#39;)  #读取csv文件
exa = pd.read_csv(&#39;... .tsv&#39;,sep=&#39;\t&#39;,index_col=&#39;..&#39;)   #读取tsv文件
exa = pd.read_csv(&#39;.... .txt&#39;,sep=&#39;|&#39;,index_col=&#39;..&#39;)  #读取txt文件
</code></pre>
<h2 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a>透视表</h2><pre><code class="python">#透视表 分组 聚合（数据的分类聚合）
#方法一
pt1=exa.pivot_table(index=&#39;...&#39;,columns=&#39;..&#39;,values=&#39;...&#39;)
#方法二
groups = exa.groupby([&#39;..&#39;,&#39;...&#39;])  #分组
sum = groups[&#39;...&#39;].sum()
count = groups[&#39;..&#39;].count()
pt2 = pd.DataFrame(&#123;&#39;...&#39;&#125;)    #新建一个表
</code></pre>
<h2 id="线性回归预测"><a href="#线性回归预测" class="headerlink" title="线性回归预测"></a>线性回归预测</h2><pre><code class="python">#线性回归 数据预测
# from scipy.stats import linregress
slope,intercept,r,p,std_err = linregress(exa.index,exa.value1) #斜率，截距...
exp = exa.index*slope+intercept  #期望


plt.scatter(exa.index,exa.value1)
plt.plot(exa.index,exp, color=&#39;red&#39;)
plt.title(f&quot;y=&#123;slope&#125;*x+&#123;intercept&#125;&quot;)
plt.xticks(exa.index,rotation = 90)
plt.tight_layout()
plt.show()  
</code></pre>
<h2 id="常见行操作"><a href="#常见行操作" class="headerlink" title="常见行操作"></a>常见行操作</h2><pre><code class="python">#行操作集锦
#追加表
exa = exa1.append(exa2).reset_index(drop = True) #将原来的index放弃
#追加行
test = pd.Series(&#123;&#39;..&#39;:&#39;..&#39;&#125;)
exa.append(test,ignore_index =True )
#更改行
exa.at[19,&#39;name&#39;] = &#39;...&#39;
#替换行
test = pd.Series(&#123;...&#125;)
exa.iloc[19] = test
#插入  到20
test = pd.Series(&#123;&#39;...&#39;&#125;)
part1 = exa[:20]
part2 = exa[20:]
exa = part1.append(test,ignore_index=True).append(part2).reset_index(drop=True)
#删除
exa.drop(index = [0,1,2],inplace =True)
#有条件删除
test= exa.loc[exa[&#39;name&#39;]==&#39;&#39;]  #删除名字为空
exa.drop(index=test,index,inplace=True )
</code></pre>
<h2 id="常见列操作"><a href="#常见列操作" class="headerlink" title="常见列操作"></a>常见列操作</h2><pre><code class="python">#常见列操作
#import numpy as np
#两张表并列放置
test = pd.concat([exa1,exa2],axis=1)
#追加列
exa[&#39;..&#39;] = np.arange(0,len(exa))  #顺序填充
#删除列
exa.drop(colume = [&#39;&#39;],implace=True)
#插入列
exa.insert(1,colunm=&#39;..&#39;,value=10) #插在1号列
#修改
exa.rename(colunm=&#123;&#39;old&#39;:&#39;new&#39;&#125;,inplace=True)
</code></pre>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>pandas编程</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能绪论</title>
    <url>/2022/08/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="the-defination-of-artificial-intelligence"><a href="#the-defination-of-artificial-intelligence" class="headerlink" title="the defination of artificial intelligence"></a>the defination of artificial intelligence</h1><blockquote>
<ul>
<li><h2 id="intelligence-wiki"><a href="#intelligence-wiki" class="headerlink" title="intelligence:(wiki)"></a>intelligence:(wiki)</h2>能够感知和推断信息的能力，并将其作为知识而拥有，已应用于环境，或语境中合适的行为    </li>
<li><h2 id="arttificial-intelligence"><a href="#arttificial-intelligence" class="headerlink" title="arttificial intelligence"></a>arttificial intelligence</h2>机器中的智能称为人工智能，其通常在运用程序，间或适当硬件的计算机系统中得以实现</li>
</ul>
</blockquote>
<h1 id="人工智能的基础"><a href="#人工智能的基础" class="headerlink" title="人工智能的基础"></a>人工智能的基础</h1><table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数学</td>
<td align="center">1.逻辑学 2.计算理论 3.概率论</td>
</tr>
<tr>
<td align="center">经济学</td>
<td align="center">1.博弈论 2.决策论 3.运筹学</td>
</tr>
<tr>
<td align="center">神经科学</td>
<td align="center">脑科学是主要研究内容</td>
</tr>
<tr>
<td align="center">认知心理学</td>
<td align="center">认知科学包括认知心理学</td>
</tr>
<tr>
<td align="center">控制理论和控制论</td>
<td align="center">是两个关联的交叉学科</td>
</tr>
</tbody></table>
<h1 id="人工智能的判定"><a href="#人工智能的判定" class="headerlink" title="人工智能的判定"></a>人工智能的判定</h1><blockquote>
<ul>
<li><h2 id="图灵测试-如何研判机器是否思维"><a href="#图灵测试-如何研判机器是否思维" class="headerlink" title="图灵测试 (如何研判机器是否思维)"></a>图灵测试 (如何研判机器是否思维)</h2>_具体内容_：人类裁判同时向被测试人和机器提出一些书面问题，经过一系列测试后，如果裁判无法分辨这些回答究竟来自人类还是机器，则判断机器通过测试，并具有人类的思维能力  </li>
<li><h2 id="图灵测试-2-0"><a href="#图灵测试-2-0" class="headerlink" title="图灵测试 2.0"></a>图灵测试 2.0</h2><table>
<thead>
<tr>
<th align="center">测试方法</th>
<th align="center">测试内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">反向图灵测试</td>
<td align="center">1.被试者的意图是使裁判将其判定为机器 2.机器掌管测试，判断测试者是否为人类</td>
</tr>
<tr>
<td align="center">学科专家图灵测试</td>
<td align="center">测试给定领域区分机器与专家</td>
</tr>
<tr>
<td align="center">总体图灵测试</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">最低智能信号测试</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">艾伯特测试</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">视觉图灵测试</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">维诺格拉德测试</td>
<td align="center">略</td>
</tr>
<tr>
<td align="center">中文房间</td>
<td align="center">略</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<h1 id="人工智能体系论"><a href="#人工智能体系论" class="headerlink" title="人工智能体系论"></a>人工智能体系论</h1><blockquote>
<p>略</p>
</blockquote>
]]></content>
      <categories>
        <category>人工智能原理</category>
      </categories>
      <tags>
        <tag>人工智能绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网数据分析</title>
    <url>/2022/09/01/%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="互联网分析的基本思路"><a href="#互联网分析的基本思路" class="headerlink" title="互联网分析的基本思路"></a>互联网分析的基本思路</h1><ul>
<li>找出问题： 描述性分析</li>
<li>分析问题： 诊断性分析，预测性分析，仿真模拟</li>
<li>解决问题： 数据报告+决策性分析</li>
</ul>
<h1 id="不同类型数据分析方法及其原理"><a href="#不同类型数据分析方法及其原理" class="headerlink" title="不同类型数据分析方法及其原理"></a>不同类型数据分析方法及其原理</h1><ul>
<li>描述性分析：通过计算数据集中性特征和波动特征以了解数据的基本情况  <ul>
<li>数值分析：数量，平均数，极差，标准差，方差，极值<br>  <img src="/../imgs/sjfx.png" alt="shuju">   </li>
<li>分布规律: 均匀分布，正态分布，长尾分布    <blockquote>
<p>利用抛骰子得到正态分布:<br>  <img src="/../imgs/sj.png" alt="shuju"><br>长尾分布:<br>  <img src="/../imgs/cw.png" alt="cw"></p>
</blockquote>
</li>
<li>可视化方法：柱状图，条形图，散点图，饼状图</li>
</ul>
</li>
<li>诊断性分析：深入挖掘问题根源，识别依赖关系，找到影响因子（关联分析）：<br><img src="/../imgs/glfx.png" alt="glfx">   <ul>
<li><h2 id="皮尔逊相关系数：（非线性数据只能用非线性模型）"><a href="#皮尔逊相关系数：（非线性数据只能用非线性模型）" class="headerlink" title="皮尔逊相关系数：（非线性数据只能用非线性模型）"></a>皮尔逊相关系数：（非线性数据只能用非线性模型）</h2><img src="/../imgs/pex.png" alt="pex"></li>
</ul>
</li>
<li>预测性分析：是用线性回归或逻辑回归的方法找到自变量与因变量之间的关系，并使该关系等式预测因变量的变化<br><img src="/../imgs/huigui.png" alt="huigui"></li>
</ul>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分析基本思路和excel实践</tag>
      </tags>
  </entry>
  <entry>
    <title>优劣势分析</title>
    <url>/2022/09/01/%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="excel简介及优劣势分析"><a href="#excel简介及优劣势分析" class="headerlink" title="excel简介及优劣势分析"></a>excel简介及优劣势分析</h1><ul>
<li>优势： <blockquote>
<p>1.对单数据源（单表格）数据分析非常灵活，方便<br>2.操作简单，分析性可复制性强，对业务指导性强   </p>
</blockquote>
</li>
<li>劣势：   <blockquote>
<p>1.对多数据源（多表格）数据分析时较为麻烦，低效<br>2.对大数据量数据分析时容易卡顿，报错</p>
</blockquote>
</li>
</ul>
<h1 id="python简介及优劣势分析"><a href="#python简介及优劣势分析" class="headerlink" title="python简介及优劣势分析"></a>python简介及优劣势分析</h1><ul>
<li>优势：<blockquote>
<p>1.可读性文字编写的语言之一，学习难度较小<br>2.数据可视化，数据分析工具包丰富，分析效率高</p>
</blockquote>
</li>
</ul>
<h1 id="如何想数据分析师一样思考问题"><a href="#如何想数据分析师一样思考问题" class="headerlink" title="*如何想数据分析师一样思考问题"></a>*如何想数据分析师一样思考问题</h1>]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>大数据分析导论</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/2022/09/13/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote>
<p>在已知条件中，选取一个条件作为树根，然后再看是否还需要其他判断条件，若需要，则继续构建一个分支来判断第二个条件，以此类推 。 最终形成的树，所有叶子节点都是要输出的类别信息，所有非叶子节点都是特征信息    </p>
</blockquote>
<p><img src="/../imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%20tree.png" alt="tree">  </p>
<h2 id="如何选择特征作为节点？"><a href="#如何选择特征作为节点？" class="headerlink" title="如何选择特征作为节点？"></a>如何选择特征作为节点？</h2><blockquote>
<p>决策树算法法使用<mark>信息增益</mark>来衡量特征之间重要性</p>
<ul>
<li>理想情况：每个叶子节点都是一个纯粹的分类  </li>
<li>实际情况：采用贪心来寻找一个最近的最优解</li>
</ul>
</blockquote>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><blockquote>
<ul>
<li>非常直观，可解释性强  </li>
<li>预测速度比较快：树 </li>
<li>可以处理离散值</li>
</ul>
</blockquote>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><blockquote>
<ul>
<li>容易过拟合</li>
<li>需要处理样本不均衡问题</li>
<li>样本变化会引发树结构巨变</li>
</ul>
</blockquote>
<h2 id="关于剪枝"><a href="#关于剪枝" class="headerlink" title="关于剪枝"></a>关于剪枝</h2><blockquote>
<ul>
<li>预剪枝：在树构建之初就设定一个阈值，当分裂节点熵阈值小于设定值时就不再进行分裂</li>
<li>后剪枝：在树构建以后根据设定来判断是否要合并一些中间节点，是叶子节点来代替</li>
</ul>
</blockquote>
<h2 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h2><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><pre><code class="python">
from sklearn import datasets
from sklearn.tree import DecisionTreeClassifier  #引入决策树算法包
import numpy as np
</code></pre>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><pre><code class="python">np.random.seed(0)
iris = datasets.load_iris()
iris_x = iris.data
iris_y = iris.target
indices = np.random.permutation(len(iris_x))   #打乱
iris_x_train = iris_x[indices[:-10]]
iris_y_train = iris_y[indices[:-10]]     #训练集
iris_x_test = iris_x[indices[-10:]]
iris_y_test = iris_y[indices[-10:]]       #测试集
</code></pre>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><pre><code class="python">
  #设置树的最大深度
clf = DecisionTreeClassifier(max_depth = 4)
clf.fit(iris_x_train,iris_y_train)         #模型训练
</code></pre>
<h3 id="决策树可视化"><a href="#决策树可视化" class="headerlink" title="决策树可视化"></a>决策树可视化</h3><pre><code class="python">#引入画图相关包 决策树可视化
from IPython.display import  Image
from sklearn import tree
import pydotplus    #程序化生成流程图的简单语言
#可视化
dot_data = tree.export_graphviz(clf,out_file=None,\
                                feature_names=iris.feature_names,\
                                class_names = iris.target_names,\
                                filled = True,\
                                rounded = True,\
                                special_characters= True)
graph = pydotplus.graph_from_dot_data(dot_data)
# graph = graphviz.Source(dot_data)
# print(graph)
Image(graph.create_png())  #输出图：判定条件，gini系数，样本数量，类别
</code></pre>
<h3 id="结果显示"><a href="#结果显示" class="headerlink" title="结果显示"></a>结果显示</h3><pre><code class="python">#预测
iris_y_predict = clf.predict(iris_x_test)
score = clf.score(iris_x_test,iris_y_test,sample_weight=None)
print(&#39;iris_y_predict = &#39;,iris_y_predict)
print(&#39;iris_y_test = &#39;, iris_y_test)
print(&#39;Accuracy: &#39;, score)
</code></pre>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习路线</title>
    <url>/2022/08/30/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>what is data?</title>
    <url>/2022/08/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><h1 id="what-is-data"><a href="#what-is-data" class="headerlink" title="what is data?"></a>what is data?</h1><blockquote>
<p>未经处理的原始记录 ：商品数据，用户数据…   </p>
</blockquote>
</li>
<li><h1 id="what-can-data-do"><a href="#what-can-data-do" class="headerlink" title="what can data do?"></a>what can data do?</h1><blockquote>
<p>描述性分析，用户价值分析，用户分类分析    </p>
</blockquote>
</li>
<li><h1 id="the-attributes-of-data"><a href="#the-attributes-of-data" class="headerlink" title="the attributes of data"></a>the attributes of data</h1><blockquote>
<ul>
<li>数据变异性： <ul>
<li>检验标准 ：标准差  极差  方差</li>
</ul>
</li>
<li>数据规律性： 正态分布    </li>
<li>数据的客观性</li>
</ul>
</blockquote>
</li>
<li><h1 id="数据分析师需要具备的知识体系："><a href="#数据分析师需要具备的知识体系：" class="headerlink" title="数据分析师需要具备的知识体系："></a>数据分析师需要具备的知识体系：</h1></li>
</ul>
<h2 id="1-业务知识"><a href="#1-业务知识" class="headerlink" title="1.业务知识"></a>1.业务知识</h2><blockquote>
<p>数据分析最终是为业务服务的。若脱离行业认知和公司业务背景，分析的结果只会是拖了线的风筝，没有太大价值。</p>
<p>熟悉行业知识，了解市场环境、行业竞争、发展趋势。</p>
<p>理解公司的商业模式，业务场景及流程。</p>
<p>不同业务的指标体系。</p>
</blockquote>
<h2 id="2-分析方法"><a href="#2-分析方法" class="headerlink" title="2.分析方法"></a>2.分析方法</h2><blockquote>
<p>掌握数据分析的基本原理与一些有效的数据分析方法，根据业务场景中分析目的不同，选择对应的分析方法。另外，统计学很重要。</p>
</blockquote>
<blockquote>
<p>基本的分析方法：逻辑树分析法、对比分析法、相关分析法、漏斗分析法、综合评价分析法、结构分解法、因素分析法、RFM分析法、AARRR模型分析法等。</p>
</blockquote>
<blockquote>
<p>高级的分析方法：因子分析法、主成分分析法、聚类分析法、关联规则分析法、时间序列分析法、线性回归分析法、A&#x2F;B test等。 </p>
</blockquote>
<h2 id="3-数据分析思维"><a href="#3-数据分析思维" class="headerlink" title="3.数据分析思维"></a>3.数据分析思维</h2><blockquote>
<p>可以透过数据发现、拆解和解决问题。了解数据分析的流程，每个流程需要注意的事项，大数据思维等。</p>
</blockquote>
<blockquote>
<p> <em>问题拆解的结构化思维</em>：MECE原则</p>
</blockquote>
<blockquote>
<p><em>数据分析的流程</em> ：明确和拆解问题→确定变量和数据获取→数据探索和预处理→统计方法、模型、算法等的应用→结果分析和决策建议→结果执行、评估和反馈。</p>
</blockquote>
<h2 id="4-专业工具的使用"><a href="#4-专业工具的使用" class="headerlink" title="4.专业工具的使用"></a>4.专业工具的使用</h2><blockquote>
<p>掌握数据分析相关的常用工具，熟悉基本操作及结果的解读等。</p>
</blockquote>
<blockquote>
<p>常用的数据分析工具有：Excel、SQL、BI、Python、R、SPSS、SAS等。</p>
</blockquote>
<blockquote>
<p>建议必学Excel和SQL，他们能解决工作中遇到的大部分问题。再根据个人需要、时间、兴趣，学习BI、Python、SPSS等分析工具   </p>
</blockquote>
<ul>
<li><h1 id="数据分析的四个步骤"><a href="#数据分析的四个步骤" class="headerlink" title="数据分析的四个步骤"></a>数据分析的四个步骤</h1><ul>
<li>数据抓取    <blockquote>
<p>   埋点<br>   爬虫<br>   api     (通过接口直接访问数据库)   </p>
</blockquote>
</li>
<li>数据质量分析   <blockquote>
<p>   缺失值分析   （空值&#x2F;遗漏值）<br>   异常值分析    (离群点分析)  箱型图<br>   一致性分析    （矛盾&#x2F;多数据源数据）<br>   数据可视化  </p>
</blockquote>
</li>
<li>描述性分析，诊断性分析….</li>
<li>业务决策    <blockquote>
<p>描述性分析<br>诊断性分析<br>预测性分析<br>仿真模拟</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>大数据分析导论</tag>
      </tags>
  </entry>
  <entry>
    <title>回到顶部功能</title>
    <url>/2022/08/31/%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><font face="GB18030 Bitmap">坏消息：新生军训要搞到中秋！！<br />好消息：这几天都下雨，反正跑不了步ψ(｀∇´)ψ </font>      </p>
<hr>
<h2 id="添加回到顶部按钮"><a href="#添加回到顶部按钮" class="headerlink" title="添加回到顶部按钮"></a>添加回到顶部按钮</h2><blockquote>
<p>在layout中添加：</p>
</blockquote>
<pre><code class="html">               &lt;!-- backtotop --&gt;
                &lt;div id = &quot;gotop&quot;&gt;
                    &lt;img src=&quot;&lt;%- rootlink %&gt;scrollup.png&quot; alt=&quot;gotop&quot;&gt;
                &lt;/div&gt;
                &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- rootlink %&gt;css/totop.css&quot;&gt;
                &lt;script&gt;
                    window.addEventListener(&quot;scroll&quot;,handle)
                    function handle()&#123;
                        var oTop = document.body.scrollTop||document.documentElement.scrollTop
                        if(oTop&gt;=200)&#123;
                            gotop.style.display = &quot;block&quot;;
                        &#125;else&#123;
                            gotop.style.display = &quot;none&quot;;
                        &#125;
                        gotop.onclick = function()&#123;
                            window.scrollTo(&#123;
                                top:0,
                                behavior:&quot;smooth&quot;
                            &#125;)
                        &#125;
                    &#125;
                &lt;/script&gt;
</code></pre>
<blockquote>
<p>在css文件夹中新建文件totop.css   </p>
</blockquote>
<pre><code class="css">#gotop&#123;
    position: fixed;
    display: none;
    right: 30px;
    bottom: 50px;
&#125;
/* #gotop img&#123;
    width: 80px;
    height: 200px;
&#125; */
#gotop img:hover&#123;
    cursor: pointer;
&#125;
</code></pre>
<h2 id="大功告成啦！"><a href="#大功告成啦！" class="headerlink" title="大功告成啦！"></a>大功告成啦！</h2><ul>
<li><h2 id="图标可以在阿里矢量图库里下载！"><a href="#图标可以在阿里矢量图库里下载！" class="headerlink" title="图标可以在阿里矢量图库里下载！"></a>图标可以在<a href="https://www.iconfont.cn/">阿里矢量图库</a>里下载！</h2>我丢在这里啦！<br><img src="/../imgs/scrollup.png" alt="picture"></li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索问题求解</title>
    <url>/2022/09/09/%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="智力游戏问题"><a href="#智力游戏问题" class="headerlink" title="智力游戏问题"></a>智力游戏问题</h1><ul>
<li>八数码难题（8-puzzle）   <blockquote>
<p>有一个3*3的棋盘，九个格子摆上八个棋子，不同棋子上标的数字不同，给定初状态和末状态，求最少移动步骤数<br><img src="/../imgs/eight.png" alt="eight"></p>
</blockquote>
</li>
<li>八皇后问题(eight queens puzzle)<blockquote>
<p>8*8的国际象棋棋盘上拜访八个皇后使其不能发生相互攻击的摆法总个数</p>
</blockquote>
</li>
<li>汉诺塔问题（hannoi tower）</li>
<li>传教士和食人族问题（missionaries and cannibals problems）<blockquote>
<p>三个传教士和三个食人族来到一条河的左岸，想度过右岸，河的左岸只有一条船(只能乘坐两个人)：当食人族的人数超过传教士，食人族就会把传教士吃掉，如何安全渡船？</p>
</blockquote>
</li>
</ul>
<h1 id="现实世界问题"><a href="#现实世界问题" class="headerlink" title="现实世界问题"></a>现实世界问题</h1><ul>
<li>最短路径问题  <blockquote>
<p>求解其中给定两个之间的最短距离<br><img src="/../imgs/shortest.png" alt="shortest"></p>
</blockquote>
</li>
</ul>
<h1 id="搜索问题要素"><a href="#搜索问题要素" class="headerlink" title="搜索问题要素"></a>搜索问题要素</h1><ul>
<li>状态表征：<blockquote>
<p>状态是问题在不同时期或不同条件所表现出的形态。问题提出时的状态称其为初始状态，问题达到预期结果时的状态为目标状态，其他为中间状态。<br>表征方法主要采用原子表征（不考虑状态的内部构造）<br><img src="/../imgs/atom.png" alt="atom">  </p>
</blockquote>
</li>
<li>状态空间：<blockquote>
<p>状态空间是问题在不同时期或在不同条件所表现出来的所有状态的有机组成。（可抽象为一张图或一棵树）  </p>
</blockquote>
</li>
<li>形式化：<blockquote>
<p>def1: 一个问题若可以表示为状态空间，并且初始状态和目标状态之间可能存在多条路径的话，就称其为搜索问题<br>def2: 一个搜索问题可以形式化为一个5元组，search &#x3D; (S,S0,A,Gt,c)</p>
<blockquote>
<p>1.S为问题空间状态集合，状态s∈S，且S不为空<br>2.s0表示初始状态<br>3.A表示动作集合，因为动作导致状态迁移，或因动作而生成后继状态<br>4.Gt是目标检测（goal test），判定给定状态是否为目标状态<br>5.c表示路径代价（path cost）</p>
</blockquote>
</blockquote>
</li>
</ul>
<h1 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h1><p>一个简单的搜索问题求解算法</p>
<pre><code class="pseudocode">agent: simple-people-solving
    imput: percept #感知
    output: an action  #搜索得出来的动作
    local：       #局部变量
        seq：一个动作序列，初始化为空
        state：一些对于当前状态的描述
        goal：一个目标，初始化为空
        problem：一个对问题的形式化处理
        action：最近的action，初始化为空
    
    state &lt;- get_current_state(state, percept) #获取当前状态
    if seq is empty then
        goal &lt;- formulate_goal(state) #对目标状态进行形式化处理
        problem &lt;- formulate_goal(state, goal) #对搜索问题进行形式化
        seq &lt;- search(problem)   #完成当前搜索任务
        if seq = failure then
            return null action
    action &lt;- first(seq)
    seq &lt;- rest(seq)
    return action
</code></pre>
<h1 id="搜索问题实例化"><a href="#搜索问题实例化" class="headerlink" title="搜索问题实例化"></a>搜索问题实例化</h1><ul>
<li><mark>八数码难题：</mark><blockquote>
<ol>
<li>状态s： 九个格子中八个数字棋子与空格的不同摆放</li>
<li>初始状态s0：任意一个状态都能成为初始状态</li>
<li>动作集合A：最简单的动作是移动空格（上下左右）</li>
<li>目标检测Gt：检查某个状态是否与目标状态的布局相符</li>
<li>路径代价c: 每一步代价为1</li>
</ol>
</blockquote>
</li>
<li><mark>八皇后问题：</mark><br>包含两个形式方法：</li>
</ul>
<ol>
<li>增量形式化： 空状态开始，到摆满n个（常用）</li>
<li>全态形式化： 初始随机摆放，移动皇后到不违法<blockquote>
<ol>
<li>状态集合：棋盘摆放1-n个皇后</li>
<li>初始状态：棋盘上没有皇后</li>
<li>动作集合： 每次添加一个皇后到任意一个空格且合法</li>
<li>目标检测： 八个皇后已摆放且合法</li>
<li>路径代价：等于添加皇后的步数</li>
</ol>
</blockquote>
</li>
</ol>
<ul>
<li><mark>传教士食人族问题</mark><br>只需左岸状态就可以推出右岸状态，左岸状态由三元组表示：S_left &#x3D; (missionary, cannibal, boat) boat&#x3D;1：表示船在左侧<blockquote>
<ol>
<li>状态集合：表示三元组的集合</li>
<li>初始状态：s0 &#x3D; (3,3,1)</li>
<li>动作集合；用船将传教士和食人族运过河</li>
<li>目标检测： s &#x3D; (0,0,0)</li>
<li>路径代价： 等于路径中的步数</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="搜索求解方式"><a href="#搜索求解方式" class="headerlink" title="搜索求解方式"></a>搜索求解方式</h1><ul>
<li><mark>树搜索</mark>  </li>
<li><mark>图搜索</mark></li>
<li><mark>无信息搜索</mark></li>
<li><mark>有信息搜索</mark></li>
</ul>
]]></content>
      <categories>
        <category>人工智能原理</category>
      </categories>
      <tags>
        <tag>搜索问题求解</tag>
      </tags>
  </entry>
  <entry>
    <title>部署到gitee</title>
    <url>/2022/08/30/%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0coding/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>coding对新手及其不友好，同步个仓库卡的要死！！！！<br>🤬🤡（还是校园网卡？小丑竟是我）</p>
<hr>
<p>##倒不如直接用gitee</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/08/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><font size=7>MySQL  安装教程</font><br>-mysql官网   </p>
<blockquote>
<p><a href="https://www.mysql.com/">click here</a>    </p>
</blockquote>
<ul>
<li><p>点击download<br><img src="/../imgs/download.png" alt="picture">   </p>
</li>
<li><p>划到下边找到community<br><img src="/../imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-31%20193150.png" alt="picture"> </p>
</li>
<li><p>找到mysql community server 点击它  </p>
</li>
<li><p>点击install for windows<br><img src="/../imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-31%20193948.png" alt="catch">   </p>
</li>
<li><p>然后下载第一个(期间点击no,thanks,不然的话就要注册帐号了)  完成后运行文件<br><img src="/../imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-31%20195231.png" alt="catch"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据建模准备</title>
    <url>/2022/09/12/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-理解数据和业务"><a href="#1-理解数据和业务" class="headerlink" title="1.理解数据和业务"></a>1.理解数据和业务</h2><h2 id="2-准备数据"><a href="#2-准备数据" class="headerlink" title="2.准备数据"></a>2.准备数据</h2><h2 id="3-数据建模"><a href="#3-数据建模" class="headerlink" title="3.数据建模"></a>3.数据建模</h2><ul>
<li><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><blockquote>
<p>分类是有监督的学习过程<br>首先要有一批已经有标签结果的数据<br> 如果缺少已知信息</p>
<ul>
<li>考虑其他方法，如聚类 </li>
<li>考虑处理数据：人工标注<br>分类问题包括：</li>
<li>二分类：是或否</li>
<li>多分类</li>
<li>多标签分类<br>解决方法：knn，决策树，随机森林，svm</li>
</ul>
</blockquote>
</li>
<li><h2 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h2><blockquote>
<p>就是把一个数据集划分成多个组，以便针对特定用户群体去开发一些特定功能（无监督的）<br>使得组内数据高度集中，和其他组的数据之间尽量远离</p>
<ul>
<li>互斥：小组与小组之间没有交集</li>
<li>相交：一条数据即可能存在a组也可能存在b组</li>
<li>层次： 一个大组还可以细分为若干个小组</li>
<li>模糊： 一个用户并不绝对属于某个小组，只能由概率表示和小组间的关系</li>
</ul>
<hr>
<ul>
<li>基于划分的聚类，通常用于互斥的小组</li>
<li>基于密度的聚类，可以用于解决数据形状不均匀的情况</li>
<li>基于层级的聚类，适用于需要对数据细分的情况： 自顶向下，全部数据从一个组开始分裂；自底向上，最开始每一条数据都是一个组，开始合并直到满足要求</li>
<li>基于模型分类：高斯分布，正态分布</li>
</ul>
</blockquote>
</li>
<li><h2 id="回归问题-regression"><a href="#回归问题-regression" class="headerlink" title="回归问题   regression"></a>回归问题   regression</h2><img src="/../imgs/datamol.png" alt="problem">  </li>
<li><h2 id="关联问题"><a href="#关联问题" class="headerlink" title="关联问题"></a>关联问题</h2><blockquote>
<p>关联分析是无监督学习，目标是挖掘隐藏在数据中的关联模式并加以利用<br>在已有的数据中寻找数据的相关关系，以期望能够使用这些规则去提升效率和业绩<br>商品销售分析，相关推荐系统分析，用户行为分析</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="模型集成-合并多个模型来提升效果"><a href="#模型集成-合并多个模型来提升效果" class="headerlink" title="模型集成 合并多个模型来提升效果"></a>模型集成 合并多个模型来提升效果</h3><ol>
<li>bagging 装袋法<br><img src="/../imgs/bagging.png" alt="bagging"></li>
<li>boosting<br><img src="/../imgs/boosting.png" alt="boosting"></li>
<li>stacking</li>
</ol>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>是对模型进行多种维度的评估，来确认模型是否可以放到先上去使用  </p>
<ul>
<li>评估指标<br><mark>混淆矩阵与准确率指标</mark><br>example：对小猪图片的辨别（二分类模型）<br><img src="/../imgs/distin.png" alt="distinct"><br>包含数值：</li>
<li>真阳性</li>
<li>真阴性</li>
<li>假阳性</li>
<li>假阴性<br><img src="/../imgs/flag.png" alt="flag"><br><img src="/../imgs/dis.png" alt="flag"><br><img src="/../imgs/matrix.png" alt="ma">  由这两个值得出roc曲线和auc值图(纵轴：真正例率)<br><img src="/../imgs/roc.png" alt="roc"><br>当roc曲线接近对角线时模型很不稳定<br>业务抽样评估可以减弱这种情况  </li>
<li>泛化能力评估  <blockquote>
<ul>
<li>overfitting<br>模型在训练集上表现良好，在测试集或者验证集上表现不佳</li>
<li>underfitting<br>在测试集，训练集都是不好</li>
</ul>
</blockquote>
</li>
<li>模型速度 ： 处理数据的开销和时间</li>
<li>鲁棒性：在错误数据或者异常数据，数据缺失时，模型是否可以给出正确结果，会不会崩溃 </li>
<li>可解释性</li>
</ul>
<h2 id="评估数据的处理"><a href="#评估数据的处理" class="headerlink" title="评估数据的处理"></a>评估数据的处理</h2><ul>
<li>随机抽样： 把数据共分成训练集和测试集，使用测试集对模型进行测试，得到准确率指标  </li>
<li>随机多次抽样：在随机抽样的基础上，进行n次随机抽样，得到n组测试集，使得这n组的平均值作为最终结果</li>
</ul>
<h2 id="模型应用"><a href="#模型应用" class="headerlink" title="模型应用"></a>模型应用</h2>]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>数据建模绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2022/09/01/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h1><p> <img src="/../imgs/linear.png" alt="linear">   </p>
<ul>
<li>如何计算系数？ <blockquote>
<p>使用最小二乘法估算系数：<br><img src="/../imgs/zuixiao.png" alt="zuixiao">   </p>
</blockquote>
</li>
<li>如何评估线性回归的好与坏？   <blockquote>
<p><img src="/../imgs/pinggu.png" alt="pinggu"><br>R^2越大线性模型就越贴切   </p>
</blockquote>
</li>
<li>如何评估回归的细节:  <blockquote>
<p>假设用python的线性回归：<br><img src="/../imgs/py_linear.png" alt="pylinear"><br>f_statistic: 自变量与因变量是否有关联（但不知道什么关联）<br>constant：常数项  （coef表示值）…<br>以下的都是系数</p>
<ul>
<li>得利用t值和p值来判断是否有意义：  <blockquote>
<p>当发现t值小，p值大，则这个参数没什么意义（参考值意义低）<br>后边的数值区间为置信区间  std err为标准差</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/2022/09/03/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>逻辑回归的本质就是由线性回归转变为非线性回归的样子：如图<br><img src="/../imgs/logi.png" alt="logi">  </p>
<blockquote>
<p>计算系数的方法：最大似然估计  </p>
<blockquote>
<ul>
<li>概率和似然的区别：<br>概率是指已知一些概率分布参数的情况下，预测观测结果<br>似然适用于已经知道某些观测所得到的结果时，对观测结果所属的概率分布参数进行估值<br><img src="/../imgs/sir.png" alt="sir"><br><img src="/../imgs/likeli.png" alt="likeli"></li>
</ul>
</blockquote>
</blockquote>
<h1 id="仿真模拟："><a href="#仿真模拟：" class="headerlink" title="仿真模拟："></a>仿真模拟：</h1><p>类似于算法分析中的随机化算法来模拟各种条件下产生的结果   </p>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯</title>
    <url>/2022/09/13/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>思路： <img src="/../imgs/beiyes.png" alt="beiyes"><br>分类理解：<img src="/../imgs/lij.png" alt="lijie">   </p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<ul>
<li>逻辑清晰，易于实现</li>
<li>适合大规模数据</li>
<li>运算开销小</li>
<li>对于噪声点和无关属性比较健壮</li>
<li>预测过程快</li>
</ul>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<ul>
<li>要考虑特征之间的相互独立性</li>
</ul>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="python">from sklearn import datasets
from sklearn.naive_bayes import GaussianNB #高斯分布的朴素贝叶斯
import numpy as np
np.random.seed(0)
iris = datasets.load_iris()
iris_x = iris.data
iris_y = iris.target
indices = np.random.permutation(len(iris_x))   #打乱
iris_x_train = iris_x[indices[:-10]]
iris_y_train = iris_y[indices[:-10]]     #训练集
iris_x_test = iris_x[indices[-10:]]
iris_y_test = iris_y[indices[-10:]]       #测试集

clf = GaussianNB()    #朴素贝叶斯分类器
clf.fit(iris_x_train,iris_y_train)

#预测
iris_y_predict = clf.predict(iris_x_test)
score = clf.score(iris_x_test,iris_y_test,sample_weight=None)
print(&#39;iris_y_predict = &#39;,iris_y_predict)
print(&#39;iris_y_test = &#39;, iris_y_test)
print(&#39;Accuracy: &#39;, score)
</code></pre>
<h2 id="拓展：-（打破局限性）"><a href="#拓展：-（打破局限性）" class="headerlink" title="拓展：  （打破局限性）"></a>拓展：  （打破局限性）</h2><ul>
<li>半朴素贝叶斯 ode    </li>
<li>aode 集成学习</li>
</ul>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>svm 支持向量机</title>
    <url>/2022/09/13/svm-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="support-vector-machine"><a href="#support-vector-machine" class="headerlink" title="support vector machine"></a>support vector machine</h1><h2 id="例子开始："><a href="#例子开始：" class="headerlink" title="例子开始："></a>例子开始：</h2><blockquote>
<p>划分红豆和绿豆   ：<br><img src="/../imgs/svm.png" alt="svm"><br><mark>svm要解决的就是怎么找到那条中轴线！</mark>    </p>
</blockquote>
<ol>
<li>首先找到一些线可以区分红豆绿豆  </li>
<li>找到正确斜率的那条线</li>
<li>确认马路宽度，得到最优解，马路的中轴线</li>
</ol>
<h2 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h2><blockquote>
<p>超平面是维度大于三维时仍然满足把空间分为两部分且是两个点距离相同的点的轨迹，自由度比空间维度小1</p>
</blockquote>
<h2 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h2><blockquote>
<p>红豆和绿豆中距离这条线最近的几个样本点<br>这些点到这条线距离称为间隔<br>在决定最佳超平面时只有支持向量起作用</p>
</blockquote>
<h2 id="不清晰边界"><a href="#不清晰边界" class="headerlink" title="不清晰边界"></a>不清晰边界</h2><blockquote>
<p>由硬间隔到软间隔：在间隔区域允许出现一定数量的样本</p>
</blockquote>
<h2 id="处理线性可分"><a href="#处理线性可分" class="headerlink" title="处理线性可分"></a>处理线性可分</h2><blockquote>
<p> 将不可划分的样本映射到高维空间中<br> 运用核函数进行上述操作：</p>
<ol>
<li>线性核函数</li>
<li>多项式核函数</li>
<li>高斯核函数</li>
</ol>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<p>有严格的数学理论支持，可解释性强<br>鲁棒性好（样本发生变化对模型没什么影响）</p>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<p>训练所需要资源很大<br>只能处理二分类问题<br>预测时间与支持向量个数成正比</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="python">from sklearn import datasets
from sklearn import svm
import numpy as np

np.random.seed(0)
iris = datasets.load_iris()
iris_x = iris.data
iris_y = iris.target
indices = np.random.permutation(len(iris_x))   #打乱
iris_x_train = iris_x[indices[:-10]]
iris_y_train = iris_y[indices[:-10]]     #训练集
iris_x_test = iris_x[indices[-10:]]
iris_y_test = iris_y[indices[-10:]]       #测试集

#使用线性核svc是分类向量机的意思，另外svr是回归支持向量机
clf = svm.SVC(kernel = &#39;linear&#39;)
clf.fit(iris_x_train,iris_y_train)  #学习

#预测
iris_y_predict = clf.predict(iris_x_test)
score = clf.score(iris_x_test,iris_y_test,sample_weight=None)
print(&#39;iris_y_predict = &#39;,iris_y_predict)
print(&#39;iris_y_test = &#39;, iris_y_test)
print(&#39;Accuracy: &#39;, score)
</code></pre>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>svm支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>人工神经网络</title>
    <url>/2022/09/13/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><blockquote>
<ul>
<li>预先设定一种网络结构和激活函数（relu，tanh， sigmoid）</li>
<li>初始化模型中的权重</li>
<li>根据输入数据和权重来预测结果</li>
<li>模型要调整误差</li>
</ul>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<p>可以像搭积木一样不断的扩展模型的边界，而对于内部具体运行不需要加以太多的干涉</p>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<p>缺乏可解释性，内部复杂<br>非常消耗资源</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>svm支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>xgb算法实践</title>
    <url>/2022/09/13/xgb%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实践：对酒店的信息进行消歧"><a href="#实践：对酒店的信息进行消歧" class="headerlink" title="实践：对酒店的信息进行消歧"></a>实践：对酒店的信息进行消歧</h2><p><img src="/../imgs/book.png" alt="xiaoqi">   </p>
<h3 id="业务理解：信息消歧"><a href="#业务理解：信息消歧" class="headerlink" title="业务理解：信息消歧"></a>业务理解：信息消歧</h3><blockquote>
<p>不同供应商对同一个酒店会有不同的信息</p>
</blockquote>
<h3 id="理解数据："><a href="#理解数据：" class="headerlink" title="理解数据："></a>理解数据：</h3><blockquote>
<ul>
<li>数据属性不同（英文，中文…）</li>
<li>数据形态不同</li>
<li>数据量大，全部对比不现实</li>
<li>消歧错误带来风险</li>
</ul>
</blockquote>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><blockquote>
<ul>
<li>提供一个算法服务以及算两条数据是否属于一个酒店</li>
<li>目标设定：提升运营效率，算法与运营人员结合实现业务目标</li>
<li>计划先对中文进行处理（占比多）</li>
</ul>
</blockquote>
<h3 id="构建特征-x2F-特征向量"><a href="#构建特征-x2F-特征向量" class="headerlink" title="构建特征 &#x2F;特征向量"></a>构建特征 &#x2F;特征向量</h3><ul>
<li>名称分词：<br><img src="/../imgs/hotel.png" alt="hotel">   </li>
<li>地址分词：<br><img src="/../imgs/hotel_loc.png" alt="loc">   </li>
<li>python 开源工具包：similarities</li>
</ul>
<h3 id="模型训练-x2F-评估"><a href="#模型训练-x2F-评估" class="headerlink" title="模型训练&#x2F;评估"></a>模型训练&#x2F;评估</h3><p><img src="/../imgs/xgb.png" alt="xgb">  </p>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>XGB算法</tag>
      </tags>
  </entry>
  <entry>
    <title>k-means聚类</title>
    <url>/2022/09/13/k-means%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算法原理（基于划分的方法）"><a href="#算法原理（基于划分的方法）" class="headerlink" title="算法原理（基于划分的方法）"></a>算法原理（基于划分的方法）</h2><blockquote>
<p>假设数据总共有m条，计划分为3个类别</p>
<ul>
<li>先随机在这个空间中选取三个点，称为中心点</li>
<li>计算所有的点到三个点的距离，这里的距离计算使用的是欧氏距离（每个点都选最近的为中心点）</li>
<li>使用每个数据计算出这些数据的一个均值，使用这个均值作为下一个迭代的中心</li>
</ul>
</blockquote>
<h2 id="如何确定k值？"><a href="#如何确定k值？" class="headerlink" title="如何确定k值？"></a>如何确定k值？</h2><blockquote>
<p>手肘法：循环尝试k值，计算在不同k值情况下，所有数据的损失即用每一个数据点到中心点的距离和计算平均距离<br><img src="/../imgs/shouz.png" alt="shouz"><br>拐点即为k值：只适用于k不这么大时</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<ul>
<li>简洁明了：计算复杂度低</li>
<li>收敛速度较快</li>
</ul>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<ul>
<li>结果不稳定</li>
<li>无法解决样本不均衡问题</li>
<li>容易收敛到局部最优点</li>
<li>受噪声影响较大</li>
</ul>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="python">from sklearn import datasets

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

&quot;&quot;&quot;画出聚类的图像
labels：聚类后的label，从0开始的数字
cents；质心坐标
n_cluster:聚类后簇的数量
color：每一簇的颜色
&quot;&quot;&quot;

def draw_result(train_x, labels, cents, title):
    n_clusters = np.unique(labels).shape[0]
    color = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;]
    plt.figure()
    plt.title(title)
    for i in range(n_clusters):
        current_data = train_x[labels == i]
        plt.scatter(current_data[:, 0], current_data[:, 1], c=color[i])
        #使用蓝色星形表示中心点位置
        plt.scatter(cents[i, 0], cents[i, 1], c=&quot;blue&quot;, marker=&#39;*&#39;, s=100)
    return plt

if __name__ == &#39;__main__&#39;:
    iris = datasets.load_iris()
    iris_x = iris.data
    # 设定聚类数目是三
    clf = KMeans(n_clusters=3, max_iter=10, n_init=10,\
                  init=&quot;k-means++&quot;,algorithm=&quot;full&quot;,\
                  tol=1e-4, random_state=1)  #n_jobs = -1 :启用计算机全部线程
    clf.fit(iris_x)
    print(&quot;SSE=&#123;0&#125;&quot;.format(clf.inertia_))
    draw_result(iris_x, clf.labels_, clf.cluster_centers_, &quot;kmeans&quot;).show()


    #sse是误差平方和，这个值越接近0说明效果越好

</code></pre>
<p><img src="/../imgs/kmeans.png" alt="kmeans"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul>
<li>K-means++<blockquote>
<p>在初始点选取中进行了优化。从已有的数据中随机进行多次选取k个中心点，每次都计算这一次选中的中心点的距离，然后取一组最大的作为初始化中心点</p>
</blockquote>
</li>
<li>mini batch K-means<blockquote>
<p>在数据量大时，运算会变得十分缓慢，在迭代时，每个集合中只选取部分点进行计算</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>k-means</tag>
        <tag>聚类问题</tag>
      </tags>
  </entry>
  <entry>
    <title>DBscan聚类</title>
    <url>/2022/09/14/DBscan%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ul>
<li><h3 id="在DBscan中，衡量密度主要使用指标："><a href="#在DBscan中，衡量密度主要使用指标：" class="headerlink" title="在DBscan中，衡量密度主要使用指标："></a>在DBscan中，衡量密度主要使用指标：</h3></li>
</ul>
<ol>
<li>半径</li>
<li>最少样本量</li>
</ol>
<ul>
<li><h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3></li>
</ul>
<ol>
<li>直接密度可达：如果一个点在核心对象的半径区域内，那么这个点和核心对象称为直接密度可达（a-b，b-c）</li>
<li>密度可达： 如果一系列的点，都满足上一个点到这个点是密度直达，那么这个系列中不相邻的点就称之为密度可达（a-d）  </li>
<li>密度相连： 如果通过一个核心对象出发，得到连个密度可达的点，那么这两个点成为密度相连（e-f）<br><img src="/../imgs/dbscan.png" alt="dbscan"></li>
</ol>
<ul>
<li><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><blockquote>
<p>经过初始化后，从整个样本集中去抽取样本点<br>如果这个样本点是核心对象，那么从这个点出发，找到所有密度可达的对象，构成一个簇<br>如果这个样本点不是核心对象，那么再重新寻找下一个点</p>
</blockquote>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<ul>
<li>不需要划分个数</li>
<li>可以处理噪声点（游离在簇外的点）</li>
<li>可以处理任意空间的聚类问题</li>
</ul>
</blockquote>
<h2 id="算法缺点："><a href="#算法缺点：" class="headerlink" title="算法缺点："></a>算法缺点：</h2><blockquote>
<ul>
<li>需要指定最小样本量和半径</li>
<li>数据量大时开销也大</li>
<li>如果样本集的密度不平均，聚类间距差相差很大时，聚类质量较差</li>
</ul>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="python">import numpy as np
from sklearn import  datasets
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import dbscan

# 生成500个点，噪声为0.1
X,_ = datasets.make_moons(500, noise=0.1, random_state=1)
df = pd.DataFrame(X,columns=[&#39;x&#39;,&#39;y&#39;])
print(df)
df.plot.scatter(&#39;x&#39;,&#39;y&#39;,s=200, alpha = 0.5, c=&quot;green&quot;,\
                title = &#39;dataset by DBscan&#39;)
plt.show()

# eps时领域半径，min_sample为最小样本量
core_samples,cluster_ids = dbscan(X, eps=0.2, min_samples=20)
#cluster_ids中-1表示对应点为噪声
df = pd.DataFrame(np.c_[X,cluster_ids], columns=[&#39;x&#39;,&#39;y&#39;,&#39;cluster_id&#39;])
df[&#39;cluster_id&#39;] = df[&#39;cluster_id&#39;].astype(&#39;i2&#39;)
#绘制结果图像
df.plot.scatter(&#39;x&#39;,&#39;y&#39;,s=200,\
                c=list(df[&#39;cluster_id&#39;]),cmap=&#39;Reds&#39;,\
                colorbar = False,alpha=0.6,\
                title=&#39;DBSCAN cluster result&#39;)
plt.show()
</code></pre>
<p><img src="/../imgs/dbscan1.png" alt="dbscan"></p>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>聚类问题</tag>
        <tag>DBsan聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>使用word2vec和k-means聚类寻找相似城市</title>
    <url>/2022/09/14/%E4%BD%BF%E7%94%A8word2vec%E5%92%8Ck-means%E8%81%9A%E7%B1%BB%E5%AF%BB%E6%89%BE%E7%9B%B8%E4%BC%BC%E5%9F%8E%E5%B8%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="理解业务"><a href="#理解业务" class="headerlink" title="理解业务"></a>理解业务</h2><blockquote>
<h3 id="一个需求"><a href="#一个需求" class="headerlink" title="一个需求"></a>一个需求</h3><p>把相似的目的地整理出来，然后可以通过这些相似目的地做相关推荐，或者是相关目的地的推荐</p>
</blockquote>
<h2 id="Word2vec算法"><a href="#Word2vec算法" class="headerlink" title="Word2vec算法"></a>Word2vec算法</h2><blockquote>
<p>可以学习输入文本，并输出一个词向量模型</p>
</blockquote>
<h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><blockquote>
<ul>
<li>对数据进行清洗，去除异常数据</li>
<li>对文本内容分词</li>
<li>把数据存储在文本文件中</li>
</ul>
</blockquote>
<h2 id="训练word2vec模型"><a href="#训练word2vec模型" class="headerlink" title="训练word2vec模型"></a>训练word2vec模型</h2><blockquote>
<p>算法包gensim：从原始的非结构化信息文本中，通过无监督算法学习文本向量表达</p>
</blockquote>
<pre><code class="python">import gensim #引入gensim
import os
import re
import sys
import multiprocessing
from time import time

class getSentence(object):
    #初始化，获取文件路径
    def __init__(self,dirname):
        self.dirname = dirname
    #构建一个迭代器
    def __iter__(self):
        for root, dirs, files in os.walk(self.dirname):
            for filename in files:
                file_path = root + &#39;/&#39; +filename
                for line in open(file_path):
                    try:
                        #清楚异常数据，主要是去除空白字符以及长度为0的内容
                        s_line= line.strip()
                        if s_line==&quot;&quot;:
                            continue
                        #把句子拆成词
                        word_line = [word for word in s_line.split()]
                        yield word_line
                    except Exception:
                        print(&quot;catch exception&quot;)
                        yield &quot;&quot;


if __name__ == &#39;__main__&#39;:
 #记录一个起始时间
    begin =time()
 #获取句子迭代器
    sentence = getSentence(&quot;.....&quot;)
 #训练word2vec模型，使用句子迭代器作为语料的输入，设定的最终向量长度为200维；
#窗口长度为15；词的最小计数为10，词频少于10的词不会进行计算；使用并列处理
    model = gensim.models.Word2Vec(sentence,size=200,window=15,min_count=10,\
                                   workers=multiprocessing.cpu_count())
#模型存储，这一块记得先预先新建一个model路径，或者也可以增加一段代码来识别是否已经创建，如果没有则新建一个路径
    model.save(&quot;model/word2vec_gensim&quot;)
    model.wv.save_word2vec_format(&quot;model/word2vec_org&quot;,\
                                  &quot;model/vocabulary&quot;,\
                                  binary=false)
    end = time()
    print(&quot;total processing time；%d seconds&quot;%(end-begin))
</code></pre>
<h2 id="训练k-means模型"><a href="#训练k-means模型" class="headerlink" title="训练k-means模型"></a>训练k-means模型</h2><pre><code class="python">import gensim
from sklearn.cluster import KMeans
from sklearn.externals import joblib
from time import time

#加载训练好的模型
def load_model():
    model=gensim.models.Word2Vec.load(&#39;../word2vec/model/word2vec_gensim&#39;)
    return model
#加载城市名称词库
def load_filterword():
    fd = open(&quot;mddwords.txt&quot;,&quot;r&quot;)
    filterword=[]
    for line in fd.readlines():
        line=line.strip()
        filterword.append(line)
    return filterword
if __name__ == &#39;__main__&#39;:
    start = time()
    #加载word2vec模型
    model=load_model()
    #加载词汇表
    filterword=load_filterword()
    #输出词汇表长度
    print(len(filterword))

    wordvector=[]
    filterkey=&#123;&#125;
    #获取我们城市名称词库的词向量
    for word in filterword:
        wordvector.append(model[word])
        filterkey[word] = model[word]
        #输出词汇数量

    print(len(wordvector))
    #训练k-means模型，这里代码设置的聚类数为2000,最大迭代次数为100，n_jobs设置为多少线程同时在跑
    #这样可以进行多组实验来消除初始化点带来的影响
    clf=KMeans(n_cluster=2000,max_iter=100,n_jobs=10)
    s=clf.fit_predict(wordvector)
    #把模型保存下来
    joblib.dump(clf,&quot;kmeans_mdd2000.pkl&quot;)
    labels=clf.labels_
    labellist=labels.tolist()
    print(clf.inertia_)
    #把所有聚类城市名称标签保存下来
    fp = open(&quot;label_mdd2000&quot;,&#39;w&#39;)
    fp.write(str(labellist))
    fp.close()
    #把所有城市名称保存下来，其中顺序与聚类标签顺序一致
    fp1 =open(&quot;keys_mdd2000&quot;,&#39;w&#39;)
    for key in filterkey:
        fp1.write(key+&#39;\n&#39;)

    print(&quot;over&quot;)
    end=time()
    print(&quot;use time&quot;)
    print(ends-tart)
</code></pre>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>聚类问题</tag>
        <tag>k-means聚类</tag>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>回归分析</title>
    <url>/2022/09/14/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线性回归算法原理"><a href="#线性回归算法原理" class="headerlink" title="线性回归算法原理"></a>线性回归算法原理</h2><blockquote>
<ul>
<li>线性：结果与特征之间是一次函数关系</li>
<li>维度众多：结果与特征之间不是一次函数关系，比如二次函数，三次函数</li>
<li>损失函数: 计算每一个样本点的结果值和当前的函数值的差值，残差平方和这是一种最常用的损失函数</li>
<li>最小二乘法：只要有一条线，就可以通过损失函数来计算假设结果为这条线的情况下，损失值的大小</li>
<li>这里的最小二乘法是要找到一组a,b的值，使得损失值达到最小</li>
</ul>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<ul>
<li>运算速度快</li>
<li>可解释性强</li>
<li>对线性关系拟合效果好</li>
</ul>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<ul>
<li>预测精确度低</li>
<li>不相关特征会影响结果</li>
<li>容易出现过拟合</li>
</ul>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="python">import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import numpy as np

#生成数据
def generateData():
    x = []
    y = []
    for i in range(0, 100):  #100条数据
        tem_x = []
        tem_x.append(i)
        x.append(tem_x)
        tem_y = []          #数据偏移量是2.128
        tem_y.append(i+2.128+np.random.uniform(-15,15))
        y.append(tem_y)
    plt.scatter(x,y,alpha=0.6)#散点图，透明度为0.6
    # plt.show()
    return x,y

# generateData()
if __name__ == &#39;__main__&#39;:
    np.random.seed(0)
    x,y = generateData()
    print(len(x))
    x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=0)

    regressor = LinearRegression()
    regressor.fit(x_train,y_train)
    y_result = regressor.predict(x_test)
    plt.plot(x_test,y_result,color=&#39;red&#39;,alpha=0.6,linewidth=3, label=&#39;predicted line&#39;)

    plt.show()
</code></pre>
<h2 id="使用线性回归预测房价"><a href="#使用线性回归预测房价" class="headerlink" title="使用线性回归预测房价"></a>使用线性回归预测房价</h2><blockquote>
<ul>
<li>数据获取<br><img src="/../imgs/data.png" alt="data"><br>选取每条数据的前十三个属性进行线性回归<br><img src="/../imgs/data2.png" alt="data">   </li>
<li>效果评估</li>
<li>mae：平均绝对误差</li>
<li>mse：均方误差</li>
<li>rmse： 均方根误差<br><img src="/../imgs/comm.png" alt="comm"></li>
</ul>
</blockquote>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="python">from sklearn.datasets import load_boston #波士顿数据集获取方法
import pandas as pd
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn import metrics
import numpy as np
from sklearn.linear_model import LinearRegression #回归方法


boston = load_boston()
#把数据和标签取出来，使用pandas的DataFrame进行封装
x = boston.data
y = boston.target
df = pd.DataFrame(x,columns=boston.feature_names)
#分割数据集，20%做测试集
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=0)
regressor = LinearRegression()
regressor.fit(x_train,y_train)#训练
#查看截距
print(regressor.intercept_)
#查看斜率
coeff_df = pd.DataFrame(regressor.ceof_,df.columns,columns=[&#39;coefficient&#39;])
print(coeff_df)

#预测
y_pred = regressor.predict(x_test)
test_df = pd.DataFrame(&#123;&#39;actual&#39;:y_test.flatten(),&#39;predicted&#39;:y_pred.flatten()&#125;)
print(test_df)

#效果评估
</code></pre>
<blockquote>
<p>画图<br><img src="/../imgs/predict_fig.png" alt="predictfid"></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群搭建</title>
    <url>/2022/08/30/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是hadoop？"><a href="#什么是hadoop？" class="headerlink" title="什么是hadoop？"></a>什么是hadoop？</h1>]]></content>
      <categories>
        <category>云计算实验</category>
      </categories>
      <tags>
        <tag>Hadoop集群搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>web测试从零开始</title>
    <url>/2022/10/02/web%E6%B5%8B%E8%AF%95%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="web测试内容"><a href="#web测试内容" class="headerlink" title="web测试内容"></a>web测试内容</h1><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><ul>
<li>功能测试</li>
<li>性能测试</li>
</ul>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul>
<li>功能测试：<ul>
<li><a href="http://www.mooctest.net/tools/">eclipse及慕测插件</a><br>  <a href="https://blog.csdn.net/weixin_44743543/article/details/105592513">参考文档</a></li>
<li><a href="https://blog.csdn.net/godot06/article/details/104378253">java环境</a></li>
<li>chromedriver环境（代码控制浏览器）</li>
<li>selenium （jar包，从java官网下载）<br>  <a href="https://blog.csdn.net/Kennen0_0/article/details/117790767">参考文档</a></li>
</ul>
</li>
<li>性能测试：<ul>
<li>JMeter客户端（用来模拟多用户）</li>
<li>Badboy客户端  （用来生成用户行为）</li>
</ul>
</li>
</ul>
<h2 id="selenium功能测试具体流程"><a href="#selenium功能测试具体流程" class="headerlink" title="selenium功能测试具体流程"></a>selenium功能测试具体流程</h2><blockquote>
<p><a href="https://blog.csdn.net/Kennen0_0/article/details/117791843?spm=1001.2014.3001.5502">参考文档</a></p>
</blockquote>
<h2 id="selenium功能测试得分技巧"><a href="#selenium功能测试得分技巧" class="headerlink" title="selenium功能测试得分技巧"></a>selenium功能测试得分技巧</h2><ul>
<li>webdriver API的使用<br>对浏览器的控制是Selenium的一个重要应用，可以对使浏览器最大化，并指定浏览器的url访问网页地址。</li>
</ul>
<pre><code class="java"> // 浏览器打开指定网址。
 driver.get(&quot;https://www.baidu.com&quot;);
 // 浏览器最大化。
 driver.manage().window().maximize();
 // 浏览器关闭
 driver.close();
</code></pre>
<ul>
<li><p>java selenium的三种等待方式</p>
<ul>
<li>强制等待<br> 这种叫强制等待，不管浏览器是否加载完了，程序都得等待3秒，3秒一到，继续执行下面的代码，作为调试很有用，有时候也可以在代码里这样等待，不过不建议总用这种等待方式，太死板，严重影响程序执行速度。<br>注意：使用强制等待要在test方法中抛出中断异常 throws InterruptedException</li>
</ul>
<pre><code class="java">Thread.sleep(3000)  // 强制等待3秒再执行下一步
</code></pre>
<ul>
<li>隐形等待<br> 一般在打开浏览器之前设置，隐性等待对整个driver的周期都起作用，会对所有页面元素等待时间操作有效，所以只要设置一次即可，不要把隐性等待当成了sleep在用，走哪儿都来一下。<br> 隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。<br> 注意这里有一个弊端，那就是程序会一直等待整个页面加载完成，也就是一般情况下你看到浏览器标签栏那个小圈不再转，才会执行下一步，<br> 但有时候页面想要的元素早就在加载完成了，但是因为个别js之类的东西特别慢，我仍得等到页面全部完成才能执行下一步，但我想等我要的元素出来之后就下一步怎么办？<br> 有办法，这就要看selenium提供的另一种等待方式——显性等待wait了。</li>
</ul>
<pre><code class="java">driver.manage().timeouts().implicitlyWai(timeout, TimeUnit.SECONDS);
</code></pre>
<ul>
<li>显性等待<br> WebDriverWait，配合该类的unti方法，就能够根据判断条件而进行灵活地等待了。这个的功能是：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。</li>
</ul>
<pre><code class="java">//设置显示等待
WebDriverWait wait = new WebDriverWait(driver, 3);
WebElement driver = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id(&quot;sb_form_q&quot;)));
driver .sendKeys(&quot;abc&quot;);
</code></pre>
</li>
</ul>
<h2 id="元素定位的方法"><a href="#元素定位的方法" class="headerlink" title="元素定位的方法"></a>元素定位的方法</h2><p>使用Selenium对Web应用进行功能测试，最重要的就是定位到目标元素，然后才能测试其是否满足功能需求。我们可以通过浏览器的自带的开发者调试工具，来获取网页元素的属性。</p>
<ul>
<li>id<br>通过元素的id属性来定位元素</li>
</ul>
<pre><code class="java">WebElement kwElement = driver.findElement(By.id(&quot;sb_form_q&quot;));
           kwElement.clear();
           kwElement.sendKeys(&quot;CSDN&quot;);
           driver.findElement(By.id(&quot;sb_go_par&quot;)).click();
</code></pre>
<ul>
<li>name<br>通过元素的name属性来定位元素</li>
</ul>
<pre><code class="java">WebElement kwElement = driver.findElement(By.name(&quot;q&quot;));
</code></pre>
<ul>
<li>classname,tag,css selector</li>
</ul>
<pre><code class="java">driver.findElement(By.className(&quot;b_searchbox&quot;));
driver.findElement(By.tagName(&quot;input&quot;));
driver.findElement(By.cssSelector(&quot;#sb_form_q&quot;));
</code></pre>
<ul>
<li>linktext</li>
</ul>
<pre><code class="html">&lt;a href=&quot;www.baidu.com&quot;&gt;
   &lt;span class=&quot;label&quot;&gt;百度一下，你就知道&lt;/span&gt;
&lt;/a&gt;
</code></pre>
<p>linkText，通过完整的链接文字去查找元素；partialLinkText，通过部分链接文字去查找元素。<br>以上面的例子为例，这个在页面上展示的就是一个超链接，我们可以通过超链接的全部或者部分文字来定位元素。</p>
<pre><code class="java">driver.findElement(By.linkText(&quot;百度一下，你就知道&quot;));
driver.findElement(By.partialLinkText(&quot;百度一下&quot;));
</code></pre>
<ul>
<li>xpath<br>XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>*** 在查找元素的各种方法中更推荐通过元素的Xpath来定位元素 ***</li>
</ul>
<pre><code class="java">driver.findElement(By.xpath(&quot;....&quot;));
</code></pre>
<ul>
<li>切换frame<br>在有些时候，一个页面会嵌套多个frame，这时候如果想要定位某一个frame中的元素，就需要切换到目标元素所在的frame中去，定位操作完成之后，返回默认文档。</li>
</ul>
<pre><code class="java">//根据id找到frame元素(上面几种定位方式都可以)，然后切换过去。
WebElement frameElement = driver.findElement(By.id(&quot;frame_id&quot;));
driver.switchTo().frame(frameElement);
//在frameElement中测试完对应的功能后需要切换回原来的frame以进行进一步的测试
driver.switchTo().defaultContent();
</code></pre>
<ul>
<li>切换handle<br>测试可能会在不同的网页窗口句柄中进行，这时候就需要在不同的句柄中进行切换，方法如下</li>
</ul>
<pre><code class="java">//两种方法都可以
//第一种方法
List&lt;String&gt; lt1 = new ArrayList&lt;String&gt;(driver.getWindowHandles());
driver.switchTo().window(lt1.get(1));
//第二种方法
Set&lt;String&gt; handles = driver.getWindowHandles();
int i = 0;
System.out.println(handles.size());
for (String handle : handles) &#123;	
    if (i==0) &#123;	
        driver.switchTo().window(handle);
        &#125;else &#123;
            i++;
        &#125;
&#125;
</code></pre>
<ul>
<li>鼠标键盘事件操作<br>在Web测试中，常见的鼠标操作有：单击、双击、右击、拖拽、悬浮等操作，这些方法封装在了Actions类中。方法有：</li>
<li>① contextClick();&#x2F;&#x2F;右击</li>
<li>② doubleClick();&#x2F;&#x2F;双击</li>
<li>③ dragAndDrop(source, target);&#x2F;&#x2F;拖拽</li>
<li>④ moveToElement();&#x2F;&#x2F; 悬浮在某一元素上</li>
</ul>
<pre><code class="java">//构造Actions类，使用该类进行鼠标的各种操作
Actions actions = new Actions(driver);
//鼠标右击
actions.contextClick(kwElement).perform();
//鼠标双击
actions.doubleClick().perform();
//鼠标悬浮在某一元素上
actions.moveToElement(kwElement).perform();
</code></pre>
<p>键盘的一些操作主要就是输入键盘上的有特殊功能的字符，比如回车键，删除键等以达到相应地目的。<br>键符封装在了Keys类中，主要有：删除、空格、制表、回车等。使用组合键Ctrl+a和Ctrl+c等还可以实现全选和复制等功能。   </p>
<pre><code class="java">//删除
kwElement.sendKeys(Keys.BACK_SPACE);
//空格
kwElement.sendKeys(Keys.SPACE);
//回车
kwElement.sendKeys(Keys.ENTER);
//选择
kwElement.sendKeys(Keys.CONTROL,&quot;a&quot;);
//复制
kwElement.sendKeys(Keys.CONTROL,&quot;c&quot;);
</code></pre>
<hr>
<h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><h2 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h2><pre><code class="java">import java.util.Iterator;
import java.util.Set;
import org.openqa.selenium.By;
import org.openqa.selenium.Cookie;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
//import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.interactions.Actions;

import com.sun.corba.se.impl.oa.poa.ActiveObjectMap.Key;
import com.sun.org.apache.xerces.internal.impl.xpath.XPath;

import sun.security.util.Length;
</code></pre>
<h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><pre><code class="java">//判断元素是否存在
    public static boolean ifElementExist(WebDriver driver, By by) &#123;
        boolean flag = true;
        try &#123;
            driver.findElement(by);
        &#125;catch(Exception e)&#123;
            flag = false;
        &#125;
        return flag;
    &#125;   
//网页句柄转化为list逆序
    public static String[] setArray(Set&lt;String&gt; h) 
    &#123;
       Iterator&lt;String&gt; iter = h.iterator(); 
       String[] b = new String[20]; 
       for(int i=h.size()-1; i&gt;=0; i--) &#123;
           b[i] = iter.next().toString();
       &#125;
       return b;
    &#125;  
//点击函数封装xpath
    public static void xpathClick(WebDriver driver,String a) throws InterruptedException
    &#123;
       driver.findElement(By.xpath(a)).click();
       Thread.sleep(1000);
    &#125;
//传值函数封装
    public static void xpathSendkey(WebDriver driver,String a,String b) throws InterruptedException
    &#123;
       driver.findElement(By.xpath(a)).sendKeys(b);
       Thread.sleep(1000);
    &#125;
</code></pre>
<h2 id="测试函数抛出异常"><a href="#测试函数抛出异常" class="headerlink" title="测试函数抛出异常"></a>测试函数抛出异常</h2><pre><code class="java">public static void test(WebDriver driver, Actions action) throws InterruptedException
</code></pre>
<h2 id="网页全屏"><a href="#网页全屏" class="headerlink" title="网页全屏"></a>网页全屏</h2><pre><code class="java">driver.get(&quot;https://y.qq.com/&quot;);
driver.manage().window().maximize(); //将浏览器最大化
</code></pre>
<h2 id="鼠标移动动作"><a href="#鼠标移动动作" class="headerlink" title="鼠标移动动作"></a>鼠标移动动作</h2><pre><code class="java">//主函数定义
Actions action =new Actions(driver);
//......
//测试函数中使用
WebElement e = driver.findElement(By.xpath(&quot;//*[@id=\&quot;content\&quot;]/div[2]/div[2]&quot;));
action.moveToElement(e).perform();
</code></pre>
<h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><pre><code class="java">Set&lt;String&gt; h = driver.getWindowHandles();//获得所有窗口,返回的set容器里面是倒序的窗口
String[] b = setArray(h);//按顺序排列窗口，放入数组
driver.switchTo().window(b[0]);
Thread.sleep(2000);
</code></pre>
<h2 id="页面关闭"><a href="#页面关闭" class="headerlink" title="页面关闭"></a>页面关闭</h2><pre><code class="java">driver.close();//当前句柄窗口
</code></pre>
<h2 id="模拟键盘操作"><a href="#模拟键盘操作" class="headerlink" title="模拟键盘操作"></a>模拟键盘操作</h2><pre><code class="java">action.sendKeys(Keys.BACK_SPACE).perform();
//webdriver 的Keys()类提供键盘上所有按键的操作
from selenium.webdriver.common.keys import Keys
//在使用键盘按键方法前需要先导入keys 类包。
//下面经常使用到的键盘操作：
send_keys(Keys.BACK_SPACE) #删除键（BackSpace）
send_keys(Keys.SPACE) #空格键(Space)
send_keys(Keys.TAB) #制表键(Tab)
send_keys(Keys.ESCAPE) #回退键（Esc）
send_keys(Keys.ENTER) #回车键（Enter）
send_keys(Keys.CONTROL,&#39;a&#39;) #全选（Ctrl+A）
send_keys(Keys.CONTROL,&#39;c&#39;) #复制（Ctrl+C）
</code></pre>
<h2 id="网页下滑操作"><a href="#网页下滑操作" class="headerlink" title="网页下滑操作"></a>网页下滑操作</h2><pre><code class="java">((JavascriptExecutor)driver).executeScript(&quot;window.scrollTo(0, 100);&quot;);
</code></pre>
<hr>
<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><ul>
<li>使用badboy按需求文档录制脚本</li>
<li>导出jmeter文件</li>
<li>在jmeter中导入文件命名线程组<br><img src="/../imgs/jmeter1.png" alt="jmeter"></li>
<li>按要求配置并发用户和合适的ramp up period，线程组执行时间<br><img src="/../imgs/jmeter2.png" alt="jmeter"></li>
<li>记得调节启动延迟<br><img src="/../imgs/jmeter3.png" alt="jmeter"></li>
<li>参数化：csv数据文件配置<br>记得将csv文件放在jmeter文件同一个目录下<br><img src="/../imgs/jmeter4.png" alt="jmeter"><br>配置值<br><img src="/../imgs/jmeter5.png" alt="jmeter"></li>
<li>关键搜索处添加事务<br><img src="/../imgs/jmeter6.png" alt="jmeter">   </li>
<li>添加集合点<br><img src="/../imgs/jmeter7.png" alt="jmeter"></li>
</ul>
]]></content>
      <categories>
        <category>web测试</category>
      </categories>
      <tags>
        <tag>web应用测试</tag>
      </tags>
  </entry>
  <entry>
    <title>移动应用测试</title>
    <url>/2022/10/18/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="https://www.yangjiulin.com/index.php/2019/07/03/windowsandroidstudioandroidsdkapppium%e9%85%8d%e7%bd%ae%e6%95%99%e7%a8%8b/">环境配置</a></h1><h1 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h1><pre><code class="java">driver.findElementById(&quot;...&quot;).click();
driver.findElementByXPath(&quot;....&quot;).click();
</code></pre>
<h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><pre><code class="java">int width=driver.manage().window().getSize().width;
int height=driver.manage().window().getSize().height;
driver.swipe(width/2,height*3/4,width/2,height/4,3000);
</code></pre>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><pre><code class="java">driver.findElementByXPath(&quot;....&quot;).sendKeys(&quot;...&quot;);
</code></pre>
<h1 id="调用系统键"><a href="#调用系统键" class="headerlink" title="调用系统键"></a>调用系统键</h1><p>强调：当没有或者找不到控件时可以使用！！！</p>
<pre><code class="java">driver.sendEvent(66);//回车
driver.sendKeyEvent(4);//返回
</code></pre>
<h1 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h1><p><a href="https://www.cnblogs.com/fnng/p/4540731.html">推荐1</a><br><a href="https://testerhome.com/topics/1045">推荐2</a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <tags>
        <tag>移动应用测试</tag>
      </tags>
  </entry>
  <entry>
    <title>java查漏补缺1</title>
    <url>/2023/03/03/java%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="object：建立编程思想"><a href="#object：建立编程思想" class="headerlink" title="object：建立编程思想"></a>object：建立编程思想</h1><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><ul>
<li>面向对象的，解释性的，跨平台的</li>
<li>强类型机制，异常处理，垃圾自动回收 保证了Java的健壮性</li>
</ul>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>变量表示内存中的一个存储区域</li>
<li>该区域有自己的名称：变量名和类型：数据类型</li>
<li>变量必须先声明后使用，即有顺序</li>
<li>在同一个作用域范围内不能重名</li>
<li>变量 &#x3D; 变量名 + 值 + 数据类型<br><strong>+的使用:</strong></li>
<li>左右两边是数值型-&gt;加法运算</li>
<li>左右两方一方为字符串时-&gt;拼接运算<br><strong>数据类型：</strong><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>数值型（整形，浮点型），字符型，bool型</td>
<td>类（class）接口（interface）数组</td>
</tr>
<tr>
<td><strong>自动类型转黄</strong></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>精度小类型自动转换为精度大类型：<blockquote>
<p>char-&gt; int-&gt; long-&gt; float-&gt; double<br>byte-&gt; short-&gt; int-&gt; long-&gt; float-&gt; double  :<del>float a &#x3D; int + 1.1</del> 因为1.1为double 1.1f是float </p>
</blockquote>
</li>
<li>自动提升原则：类型自动提升为操作数中最大类型：byte short char 三者可以计算 首先转化为int类型<br><strong>基本数据类型与string的转换</strong><blockquote>
<p>基本类型-&gt;string：string str &#x3D; 基本类型+””;<br>string -&gt; 基本类型： Integer.perseInt(“…”);</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符介绍</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+-*&#x2F;%…</td>
</tr>
<tr>
<td>关系运算符</td>
<td>(结果：boolean) &#x3D;&#x3D; !&#x3D; &lt; &gt; …</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>+&#x3D; -&#x3D; &#x3D; …</td>
</tr>
<tr>
<td>三元运算符</td>
<td>…?…:…</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>键盘输入语句</strong><br>导入该类的包<br>创建该类的对象<br>调用功能</p>
</blockquote>
<pre><code class="java">import java.util.Scanner;
....
Scanner scanner = new Scanner(System.in);
String str = scanner.next();//.nextInt, .nextDouble
</code></pre>
<blockquote>
<p>进制：<br>二进制：0b开头 八进制:数字0开头 十六进制：0x开头<br>位运算：&gt;&gt; , &lt;&lt; , &gt;&gt;&gt;(算术)</p>
</blockquote>
<hr>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><table>
<thead>
<tr>
<th>控制结构</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>顺序结构</td>
<td></td>
</tr>
<tr>
<td>分支控制</td>
<td>if, else, switch</td>
</tr>
<tr>
<td>循环控制</td>
<td>for， while， dowhile，多重循环</td>
</tr>
<tr>
<td></td>
<td>break, continue, return</td>
</tr>
</tbody></table>
<blockquote>
<p>switch基本语法</p>
</blockquote>
<pre><code class="java">switch(表达式)&#123;
    case 常量1:...；break;
    case 常量2:...；break;
    default: ... 语句块；break;
&#125;
</code></pre>
<hr>
<h2 id="数组排序和查找"><a href="#数组排序和查找" class="headerlink" title="数组排序和查找"></a>数组排序和查找</h2><blockquote>
<p><strong>数组</strong><br>定义一个数组：double[] name &#x3D; {…}<br>动态初始化： 1.int a[] &#x3D; new int[5];   2.double name[]; &#x2F;&#x2F;声明，不分配空间 … name &#x3D; new double[5];<br>静态初始化： int a[] &#x3D; {…};<br>注意事项：数组创建后，如果没有赋值，有默认值：<br>int-&gt;0；short&#x2F;byte&#x2F;long-&gt;0; float&#x2F;double-&gt;0.0; char-&gt;\u0000;boolean-&gt;false; String-&gt;null<br>数组属于引用类型，数组型数据是对象</p>
</blockquote>
<p><strong>数组赋值机制</strong></p>
<blockquote>
<p>基本数据类型赋值：互不影响（值拷贝）<br>数组在默认情况下是引用传递，赋值是地址 （引用传递）  </p>
</blockquote>
<ul>
<li>数组拷贝：<blockquote>
<p>int[] arr1 &#x3D; {….}; int[] arr2 &#x3D; new int[arr1.length]; 再遍历赋值</p>
</blockquote>
</li>
<li>多维数组<blockquote>
<p>动态初始化： int[][] name &#x3D; new int[…][…];(也可以先声明，再new！)</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="面向对象（中级）"><a href="#面向对象（中级）" class="headerlink" title="面向对象（中级）"></a>面向对象（中级）</h2><ul>
<li>对象内存布局：(以cat为例)<blockquote>
<p><img src="/../imgs/object.png" alt="memory"></p>
</blockquote>
</li>
<li>成员方法<blockquote>
<p>访问修饰符：public,protected, private</p>
</blockquote>
</li>
<li>重载<blockquote>
<p>类中允许同名方法存在，但要求形参列表不一致，返回类型：无要求</p>
</blockquote>
</li>
<li>可变参数<blockquote>
<p>java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法</p>
</blockquote>
</li>
</ul>
<pre><code class="java">public int sum(int ... a)&#123;
    ....;//可以把a当成数组：a.length
    //实参可以是数组
    //- [#]可变参数可以和普通参数一起放在列表中，但要保证可变参数放在最后
    //- [#]一个形参列表中只能出现一个可变参数
&#125;
</code></pre>
<ul>
<li>构造器<blockquote>
<p>构造器修饰符可以默认<br>构造器没有返回值<br>方法名和类名字必须一样<br>参数列表和成员方法一样的规则<br>构造器的调用由系统完成(自动调用)<br>系统会自动定义一个构造器，除非程序员定义了自己的构造器</p>
</blockquote>
</li>
<li>对象创建流程分析<blockquote>
<p>1.变量的默认初始化<br>2.类定义的初始化<br>3.构造器的初始化</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="面向对象（中级）-1"><a href="#面向对象（中级）-1" class="headerlink" title="面向对象（中级）"></a>面向对象（中级）</h2><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ul>
<li>IDEA<blockquote>
<p>删除当前行：ctrl+d<br>补全代码：alt+&#x2F;<br>添加注释：ctrl+&#x2F;</p>
</blockquote>
</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><blockquote>
<p>作用：<br>1.区分相同名字的类<br>2.类多时，可以很好的管理类<br>3.控制访问范围</p>
</blockquote>
<pre><code class="java">package com.hello  //后面是包名
</code></pre>
<blockquote>
<p>命名规范：<br>com.公司名.项目名.业务模块名<br>java常用的包：</p>
</blockquote>
<pre><code class="java">java.lang.* //默认引入
java.util.* //系统提供的工具包
java.net.* //网络包 网络开发
java.awt.* //java界面开发，Gui
</code></pre>
<blockquote>
<p>引入包</p>
</blockquote>
<pre><code class="java">import ...
</code></pre>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li>public :公开级别</li>
<li>protected：对子类和同一个包中公开</li>
<li>默认级别（没有修饰符）：同一个包的类公开</li>
<li>private：只有类本身可以访问，不对外公开</li>
</ul>
<h3 id="封装（面向对象三大特征之一encapsulation）"><a href="#封装（面向对象三大特征之一encapsulation）" class="headerlink" title="封装（面向对象三大特征之一encapsulation）"></a>封装（面向对象三大特征之一encapsulation）</h3><p>就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序在其它部分只有通过被授权的操作[方法]，才能对数据进行操作。</p>
<h3 id="继承（面向对象三大特征之一extends）"><a href="#继承（面向对象三大特征之一extends）" class="headerlink" title="继承（面向对象三大特征之一extends）"></a>继承（面向对象三大特征之一extends）</h3><blockquote>
<p>解决代码复用</p>
</blockquote>
<ul>
<li>基本语法</li>
</ul>
<pre><code class="java">class Son extends Father&#123;
    ...;
    // 子类拥有父类定义的属性方法
&#125;
</code></pre>
<ul>
<li>子类继承了所有属性和方法，但是私有属性不能在子类直接访问，要通过公共方法去访问</li>
<li>子类必须调用父类的构造器，完成父类的初始化</li>
<li>子类默认调用父类无参构造函数，否则要用super调用指定的父类构造函数</li>
<li>super&#x2F;this 使用时需要放在构造函数第一行，因此构造器中不能同时存在super和this关键字</li>
<li>java所有类都是object类的子类</li>
<li>java 只支持单继承</li>
</ul>
<h3 id="多态（面向对象三大特征之一）"><a href="#多态（面向对象三大特征之一）" class="headerlink" title="多态（面向对象三大特征之一）"></a>多态（面向对象三大特征之一）</h3><p>方法或对象具有多种形态</p>
<ul>
<li>方法的多态：重写和重载</li>
<li>对象的多态：用父类的引用指向子类对象</li>
<li>属性没有重写之说，直接看编译类型（注意编译类型和运行类型（实际类型）instanceof 判断的是运行类型）</li>
</ul>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><ul>
<li>可以调用父类的所有成员，不能调用子类的特有成员</li>
</ul>
<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul>
<li>只能强转父类的引用，不能强转父类对象</li>
</ul>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><ul>
<li>代表父类的引用，用于访问父类的属性和方法，构造器</li>
<li>访问父类属性，方法，但不能访问private</li>
<li>super访问遵循就近原则</li>
</ul>
<h3 id="overwrite"><a href="#overwrite" class="headerlink" title="overwrite"></a>overwrite</h3><p>就是子类有一个方法，和父类的某个方法的名称，返回类型，参数一样，那么我们就说子类的这个方法覆盖了父类的方法。</p>
<h3 id="java动态绑定机制"><a href="#java动态绑定机制" class="headerlink" title="java动态绑定机制"></a>java动态绑定机制</h3><ul>
<li>当调用对象方法时，该方法会和该对象的内存地址&#x2F;运行类型绑定</li>
<li>调用属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ul>
<h3 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h3><ul>
<li>equals(object obj)<ul>
<li>&#x3D;&#x3D; <blockquote>
<p>1.判断基本类型，判断值是否相等<br>2.判断引用类型，判断地址是否相等</p>
</blockquote>
</li>
</ul>
<pre><code class="java">public boolean equals(Object obj)&#123;
    if(this == obj)&#123;
        return true;     //判断是否为同一对象
    &#125;
    if(obj instanceof Person)&#123; //判断是否为该类型
        Person p = (Person)obj; //向下转型
        return ...==... ;
    &#125;
    return false;
&#125;
</code></pre>
</li>
<li>finalize()<ul>
<li>当垃圾回收器确定不存在该对象的不同引用时，被调用</li>
<li>垃圾回收机制的主动调用：system.gc()(因为不能时时监控)</li>
</ul>
</li>
<li>getClass()</li>
<li>hashCode()<ul>
<li>返回哈希值，为了提高哈希表的性能</li>
<li>哈希值主要根据地址号来重写，不能完全等价于地址</li>
</ul>
</li>
<li>toString()<ul>
<li>默认返回：全类名+@+哈希值的十六进制</li>
</ul>
</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>略</p>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java查漏补缺2</title>
    <url>/2023/03/05/java%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h1><pre><code class="java">class classname&#123;
    public static int count = 0;
    ...
&#125;
</code></pre>
<ul>
<li>被所有类对象共享</li>
<li>类方法：<blockquote>
<p>访问修饰符 static 数据返回类型 方法名(){}</p>
</blockquote>
</li>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区中</li>
</ul>
<h1 id="理解main方法语法-static"><a href="#理解main方法语法-static" class="headerlink" title="理解main方法语法 static"></a>理解main方法语法 static</h1><ul>
<li>java 虚拟机需要调用类的main方法，所以该方法的访问权限必须是public</li>
<li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数<blockquote>
<p><img src="/../imgs/main.png" alt="main"></p>
</blockquote>
</li>
</ul>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ul>
<li>又称初始化块，属于类中的成员，将逻辑语句封装在方法中，通过{}包围起来</li>
<li>没有方法名，返回值，参数，只有方法体，不能通过对象显示调用，而是加载类时，创建类时隐式调用<blockquote>
<p>[修饰符]{  &#x2F;&#x2F;要么是static 要么不写<br>  代码<br>};&#x2F;&#x2F;可以省略</p>
</blockquote>
</li>
<li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化操作</li>
<li>static代码块也叫静态代码块，作用就是对类进行初始化，而且随着类的加载而进行，并且只执行一次，如果是普通代码块，每创建一个对象就执行一次</li>
</ul>
<h2 id="创建一个对象时，类的调用顺序是："><a href="#创建一个对象时，类的调用顺序是：" class="headerlink" title="创建一个对象时，类的调用顺序是："></a>创建一个对象时，类的调用顺序是：</h2><ol>
<li>调用静态代码块+静态属性初始化（同级按照定义顺序调用）</li>
<li>普通代码块+普通属性初始化</li>
<li>调用构造方法</li>
</ol>
<h2 id="在继承关系中调用顺序是："><a href="#在继承关系中调用顺序是：" class="headerlink" title="在继承关系中调用顺序是："></a>在继承关系中调用顺序是：</h2><ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类普通代码块和普通属性初始化</li>
<li>父亲的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><ul>
<li>就是在软件运行过程中，采取一定办法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法<br>饿汉式：（创建了对象没有使用，会造成浪费）<blockquote>
<ol>
<li>构造器私有化：防止用户new</li>
<li>类的内部创建对象 </li>
<li>向外暴漏一个静态公共方法 getInstance<br>懒汉式：</li>
<li>构造器私有化</li>
<li>定义一个static静态属性对象（没有new！！！）</li>
<li>提供一个public static 方法 new，可以返回一个对象</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ol>
<li>当不希望类被继承时，可以用final修饰</li>
<li>当不希望父类的某个方法被子类覆盖&#x2F;重写时，可以使用final关键字修饰</li>
<li>当不希望某个属性的值被修改，可以用final修饰（又称常量，必须赋初值：1.定义时2.构造器中（非static修饰）3.初始化块中）</li>
<li>当不希望某个局部变量被修改，可以使用final修饰</li>
<li>final不能修饰构造器</li>
<li>包装类（Integer&#x2F;String&#x2F;…）都是被final修饰</li>
</ol>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>当父类一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<ul>
<li>抽象类可以有任意成员</li>
<li>抽象犯法不能有主体，即不能实现</li>
<li>如果一个类继承了抽象类，则它必须实现抽象方法，否则自己也为抽象类</li>
</ul>
<h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p>利用抽象类整合复用代码，调用抽象方法，抽象方法由子类实现</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再更具体情况把这些方法写出来。</p>
<pre><code class="java">interface 接口名&#123;
    //属性
    //方法
&#125;

class 类名 implements 接口&#123;
    //自己属性
    //自己方法
    //必须实现的接口方法
&#125;
</code></pre>
<ul>
<li>接口不能被实例化</li>
<li>接口所有方法是public方法，接口中抽象方法，可以不用abstract</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都实现（抽象类例外）</li>
<li>一个类同时可以实现多个接口</li>
<li>接口中的属性，只能是public static final</li>
<li>一个接口不能继承其它类，但是可以继承多个接口</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>一个类的内部完整的嵌套了另一个类的结构，被嵌套的类的结构被称为内部类<br>最大特点就是：可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<ul>
<li>定义在外部类局部位置上的（比如说方法）<ul>
<li>局部内部类（有类名）<blockquote>
<p>可以直接访问外部类的所有成员<br>不能添加访问修饰符<br>作用域仅仅在于定义它的方法或者代码块中</p>
</blockquote>
</li>
<li>匿名内部类（无类名）</li>
<li>是类同时也是对象</li>
</ul>
<pre><code class="java">类名 对象名 = new 类或接口(参数列表)&#123;
    类体;
&#125;;
</code></pre>
</li>
<li>定义在外部类的成员位置上：<ul>
<li>成员内部类（没用static修饰）<blockquote>
<p>外部其它类调用内部类： 外部类.内部类 类名 &#x3D; 外部类.new 内部类();</p>
</blockquote>
</li>
<li>静态内部类（使用static修饰）<ul>
<li>可以访问外部类的所有静态成员，包含私有，但不能直接访问非静态成员</li>
<li>外部类访问静态内部类：创建内部类对象访问</li>
<li>外部其他类访问内部静态类</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><ul>
<li>自定义类实现枚举<blockquote>
<p>将构造器私有化，同时在类中定义public static final 类对象（对象名一般大写）</p>
</blockquote>
</li>
<li>enum关键字实现枚举<ul>
<li>继承Enum类</li>
<li>.name()： 输出对象名(枚举对象名)</li>
<li>.ordinal()：输出枚举对象的次序，从0开始</li>
<li>.values()：输出含有定义的所有枚举对象，数组</li>
</ul>
</li>
</ul>
<pre><code class="java">enum 枚举类名&#123;
    常量名1（一般大写）(实参列表), 常量2...;//最前面,且都是静态对象
    ...
    形参...;
&#125;
</code></pre>
<ul>
<li>JDK内置的基本注解类型</li>
<li>元注解：对注解进行注解</li>
</ul>
<hr>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><ul>
<li>异常概念</li>
<li>异常体系图</li>
<li>常见的异常</li>
<li>异常处理</li>
<li>自定义异常</li>
<li>throw和throws的对比</li>
</ul>
<h1 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h1><ul>
<li><p>compareTo():比较对象编号的差</p>
</li>
<li><p>valueOf():<br>将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常。<br>1.使用enum关键字，就不能继承其它类了，因为enum会隐式继承Enum<br>2.枚举类和普通类一样，可以实现接口</p>
</li>
</ul>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><p>注解也被称为元数据，用于修饰包，类，属性，方法，构造器，局部变量等数据信息</p>
<ul>
<li>三个基本annotation:</li>
</ul>
<ol>
<li>@Override:<br>限定某个方法，是重写父类方法，该注解只能用于方法</li>
<li>@Deprecated:<br>用于表示某个程序元素已经过时</li>
<li>@SuppressWarnings(“all”):<br>抑制编译器警告</li>
</ol>
<h1 id="元注解（了解，看得懂源码）"><a href="#元注解（了解，看得懂源码）" class="headerlink" title="元注解（了解，看得懂源码）"></a>元注解（了解，看得懂源码）</h1><ol>
<li>@Retention<br>指定注解作用范围：SOURCE，CLASS，RUNTIME</li>
<li>@Doucumented<br>指定注解是否会在javadoc体现</li>
<li>@Inherited<br>子类会继承父类注解</li>
<li>@Target<br>修饰注解的注解，叫元注解</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><table>
<thead>
<tr>
<th>五大运行时异常</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1.NullPointerException</td>
<td>空指针异常</td>
</tr>
<tr>
<td>2.ArithmetricException</td>
<td>数学运算异常</td>
</tr>
<tr>
<td>3.ArrayIndexOutOfBiundsException</td>
<td>数组下标越界异常</td>
</tr>
<tr>
<td>4.ClassCastException</td>
<td>类型转换异常</td>
</tr>
<tr>
<td>5.NumberFormatException</td>
<td>数字格式不正确异常</td>
</tr>
</tbody></table>
<ul>
<li>异常处理的两种机制<br>1.try-catch-finally<br>2.throws将异常抛出<br>throws后边的异常类型可以是方法中产生的一场类型，也可以是它的父类<br>子类重写父类方法时，子类重写的方法抛出的异常要么和父类一致，要么是子类异常</li>
</ul>
<pre><code class="java">public void method() throws Exception&#123;

&#125;
</code></pre>
<ul>
<li>自定义异常<br>例如年龄抛出异常：</li>
</ul>
<pre><code class="java">...
public static void main(String[] args)&#123;
    int age = 80;
    if( !(age &gt;= 18 &amp;&amp; age &lt;= 120))&#123;
        throw new AgeException(&quot;年龄错误！&quot;);
    &#125;
&#125;

//自定义一个异常
class AgeException extends RuntimeException&#123;
    // 自定义构造器
    public AgeException(String message)&#123;
        super(message);
    &#125;
&#125;
</code></pre>
<hr>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<ul>
<li>包装和拆箱<ul>
<li>在jdk5前要手动包装拆箱</li>
</ul>
<pre><code class="java">int i =10;
Integer i1 = new Integer(i);
Integer i2 = Interger.valueOf(i); //注意该函数在-127~128中不是new出来的
//拆
Integer j = new Integer(99);
int j1 = j.intValue();
</code></pre>
</li>
<li>包装类型和String类型相互转换</li>
</ul>
<pre><code class="java">Integer i =10;
//1
String s1 = i.tpString();
//2
String s2 = String.valueOf(i);
//3
String s3 = i + &quot;&quot;;
//1
Integer j = new Integer(s1);
//2
Integer j1 = Integer.valueOf(s2);
</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code class="java">String s = &quot;....&quot;；
String s2 = new String(&quot;...&quot;); //会在堆里边创建value（常量池的地址）
</code></pre>
<table>
<thead>
<tr>
<th>String常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>equals</td>
<td>区分大小写是否相等</td>
</tr>
<tr>
<td>equalsIgnoreCase</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>length</td>
<td>字符长度</td>
</tr>
<tr>
<td>indexof</td>
<td>获取字符第一次出现的索引（0开始）</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>最后一次</td>
</tr>
<tr>
<td>substring</td>
<td>截取字符串（左闭右开区间）</td>
</tr>
<tr>
<td>trim</td>
<td>去除前后空格</td>
</tr>
<tr>
<td>charAt</td>
<td>获取某个索引位置的字符串</td>
</tr>
<tr>
<td>toUpperCase</td>
<td>大写</td>
</tr>
<tr>
<td>toLowerCase</td>
<td>小写</td>
</tr>
<tr>
<td>concat</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>replace</td>
<td>替换字符串，返回一个替换的结果</td>
</tr>
<tr>
<td>split</td>
<td>将字符串分割，‘\’要转义</td>
</tr>
<tr>
<td>compareTo</td>
<td></td>
</tr>
<tr>
<td>toCharArray</td>
<td>转为字符数组</td>
</tr>
<tr>
<td>format</td>
<td>就像c里的printf</td>
</tr>
</tbody></table>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul>
<li>StringBuffer是一个容器</li>
<li>存放在堆中，是个final类</li>
<li>字符串的更新不用每次更新地址</li>
</ul>
<pre><code class="java">StringBuffer stringbuffer = new StringBuffer(&quot;...&quot;);//空参数时是空的16个位置的char数组
</code></pre>
<ul>
<li>String同StringBuffer之间的相互转换</li>
</ul>
<pre><code class="java">//String -&gt; StringBuffer
String s = &quot;hello&quot;;
//1
StringBuffer b1 = new StringBuffer(s);
//2
b1.append(s);
//StringBuffer -&gt; String
//1
String s2 = b1.toString();
//2
String s3 = new String(b1);
</code></pre>
<ul>
<li>StringBuffer方法<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>append</td>
<td>增</td>
</tr>
<tr>
<td>delete</td>
<td>删（左闭右开）</td>
</tr>
<tr>
<td>replace</td>
<td>改（左闭右开）</td>
</tr>
<tr>
<td>indexOf</td>
<td>查：第一次出现的索引，找不到-1</td>
</tr>
<tr>
<td>insert</td>
<td>插，原来索引的字符串后移</td>
</tr>
<tr>
<td>length</td>
<td>获取长度</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ul>
<li>不是线程安全的（单线程快）</li>
<li>用作StringBuffer的建议替换</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul>
<li>均为静态方法<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>abs</td>
<td>绝对值</td>
</tr>
<tr>
<td>pow</td>
<td>求幂</td>
</tr>
<tr>
<td>ceil</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor</td>
<td>向下取整</td>
</tr>
<tr>
<td>round</td>
<td>四舍五入</td>
</tr>
<tr>
<td>sqrt</td>
<td>求开方</td>
</tr>
<tr>
<td>random</td>
<td>求随机数：返回[0,1)(返回任意两个数间的：[a,a+rondom*(b-a)])</td>
</tr>
<tr>
<td>max</td>
<td>求最大值</td>
</tr>
<tr>
<td>min</td>
<td>求最小值</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Date-Calender-LocalDate"><a href="#Date-Calender-LocalDate" class="headerlink" title="Date,Calender, LocalDate"></a>Date,Calender, LocalDate</h2><ul>
<li>有三代日期类</li>
</ul>
<h3 id="Date：精确到毫秒，代表特定瞬间-SimpleDateFormat配套使用"><a href="#Date：精确到毫秒，代表特定瞬间-SimpleDateFormat配套使用" class="headerlink" title="Date：精确到毫秒，代表特定瞬间+SimpleDateFormat配套使用"></a>Date：精确到毫秒，代表特定瞬间+SimpleDateFormat配套使用</h3><pre><code class="java">Date d1 = new Date();
SimpleDateFormat sdf = new SimpleDateFormat(&quot;YYYY年MM月DD日 hh:mm:ss E&quot;);
String format = sdf.format(d1);
</code></pre>
<h3 id="Calender"><a href="#Calender" class="headerlink" title="Calender"></a>Calender</h3><ul>
<li>是一个抽象类，并且构造器是private</li>
<li>可以通过getInstance()来获取实例</li>
<li>没有相应的格式化</li>
</ul>
<pre><code class="java">Calender c = Calender.getInstance();
</code></pre>
<table>
<thead>
<tr>
<th>~</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>c.get(Calender.MONTH)+1</td>
<td>月从0开始</td>
</tr>
<tr>
<td>c.get(Calender.HOUR)</td>
<td></td>
</tr>
<tr>
<td>c.get(Calender.YEAR)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><ul>
<li>常见类  可以对时间加减<table>
<thead>
<tr>
<th>常见类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>LocalDate</td>
<td>只包含日期</td>
</tr>
<tr>
<td>LocalTime</td>
<td>只包含时间</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>包含时间日期</td>
</tr>
</tbody></table>
</li>
</ul>
<pre><code class="java">LocalDateTime ldt = LocalDateTime.now();
ldt.getYear();
</code></pre>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>exit()</td>
<td>退出当前程序(0表示正常状态)</td>
</tr>
<tr>
<td>currentTimeMillens()</td>
<td>返回当前相对于1970-1-1的毫秒数</td>
</tr>
<tr>
<td>gc()</td>
<td>运行垃圾回收机制</td>
</tr>
</tbody></table>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><table>
<thead>
<tr>
<th>常见方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>.toString()</td>
<td>返回数组字符串形式</td>
</tr>
<tr>
<td>.sort()</td>
<td>自然排序或者自定义排序</td>
</tr>
<tr>
<td>.binarySearch()</td>
<td>二分查找，必须先排序(不存在返回-（应该存在的位置+1）)</td>
</tr>
<tr>
<td>.copyOf()</td>
<td>数组元素复制</td>
</tr>
<tr>
<td>.equals()</td>
<td>比较是否相等</td>
</tr>
<tr>
<td>.asList()</td>
<td>将一组值转换为list</td>
</tr>
</tbody></table>
<ul>
<li>定制排序器</li>
</ul>
<pre><code class="java">Array.sort(arr, new Comparator()&#123;
    @Override 
    public int compare(Object o1, Object o2)&#123;
        return o1-o2;
    &#125;
&#125;);
</code></pre>
<h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><ul>
<li>BigInteger适合保存比较大的整形</li>
<li>BigDecimal适合保存精度更高的浮点型（小数）</li>
</ul>
<pre><code class="java">BigInteger bigInteger = new BigInteger(&quot;99999999999999999&quot;);
</code></pre>
<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><ul>
<li>Collection(实现单列集合)<ul>
<li>List<ul>
<li>ArrayList(类)（线程不安全，基本和Vector一样）</li>
<li>LinkedList(类)（双向链表）（线程不安全）</li>
<li>Vector(类)（多线程安全）</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet(类)（底层其实是hashmap）</li>
<li>TreeSet(类)</li>
</ul>
</li>
</ul>
</li>
<li>Map（实现双列集合）<ul>
<li>HashTable(类)<ul>
<li>Properties(类)</li>
</ul>
</li>
<li>HashMap(类)(线程不安全)<ul>
<li>LinkedHashMap(类)</li>
</ul>
</li>
<li>TreeMap(类)</li>
</ul>
</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><table>
<thead>
<tr>
<th>Collection接口常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>.add()</td>
<td>添加单个元素</td>
</tr>
<tr>
<td>.remove()</td>
<td>删除指定元素(可以下标和元素)</td>
</tr>
<tr>
<td>.contains()</td>
<td>查找指定元素是否存在</td>
</tr>
<tr>
<td>.size()</td>
<td>获取元素个数</td>
</tr>
<tr>
<td>.isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>.clear()</td>
<td>清空</td>
</tr>
<tr>
<td>.addAll()</td>
<td>添加多个元素，参数是一个集合</td>
</tr>
<tr>
<td>.containsAll()</td>
<td>查找多个元素是否都存在</td>
</tr>
<tr>
<td>.removeAll()</td>
<td>删除多个元素</td>
</tr>
</tbody></table>
<ul>
<li>Collection的遍历方式-使用Iterator（迭代器）</li>
</ul>
<pre><code class="java">//返回迭代器
Iterator iterator = arraylist.iterator();
while(iterator.hasNext())&#123; //遍历
    ....iterator.next();//返回object类型
&#125;  
</code></pre>
<ul>
<li>集合增强for</li>
</ul>
<pre><code class="java">for(Object ob: list)&#123;   //底层依然是迭代器
    ...;
&#125;
</code></pre>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li>List接口中的元素有序，且可重复</li>
<li>支持索引（0开始） <table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>add(index, object)</td>
<td>向指定位置添加元素</td>
</tr>
<tr>
<td>get(index)</td>
<td>获取指定位置元素Object</td>
</tr>
<tr>
<td>remove(index)</td>
<td>移除指定位置元素</td>
</tr>
<tr>
<td>set(index, object)</td>
<td>设置指定位置元素</td>
</tr>
<tr>
<td>subList（index, index）</td>
<td>返回子集合（闭区间）</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>无序</li>
<li>不允许重复元素（最多包含一个null）</li>
<li>不能通过索引进行遍历</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>保存具有映射关系的数据Key-Value</li>
<li>key不允许重复，value允许重复</li>
<li>String常用来作为key</li>
<li>重复会替换原来的值</li>
</ul>
<table>
<thead>
<tr>
<th>Map常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>put</td>
<td>添加</td>
</tr>
<tr>
<td>remove</td>
<td>删除by键</td>
</tr>
<tr>
<td>get</td>
<td>获取by键</td>
</tr>
<tr>
<td>size</td>
<td>元素个数</td>
</tr>
<tr>
<td>isEmpty</td>
<td>判断个数是否为0</td>
</tr>
<tr>
<td>clear</td>
<td>清除</td>
</tr>
<tr>
<td>containsKey</td>
<td>查找键</td>
</tr>
<tr>
<td>keySet</td>
<td>获取所有键</td>
</tr>
<tr>
<td>entrySet</td>
<td>获取所有关系</td>
</tr>
<tr>
<td>values</td>
<td>获取所有值</td>
</tr>
</tbody></table>
<ul>
<li>Map遍历方法</li>
</ul>
<ol>
<li>keySet()取出所有的键，根据键来取出值</li>
<li>通过entrySet来获取K-V：</li>
</ol>
<pre><code class="java">Set entrySet = mymap.entrySet();
for(Object entry: entrySet)&#123;
    Map.Entry m = (Map.Entry) entry;
    ...  .getKey()/.getValue();
&#125;
</code></pre>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections(工具类)"></a>Collections(工具类)</h2><ul>
<li>Collections是一个操作Set，List，Map等集合的工具类</li>
<li>Collections提供了一系列静态方法对集合元素进行排序，查询和修改</li>
</ul>
<table>
<thead>
<tr>
<th>排序操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>reverse()</td>
<td>反转</td>
</tr>
<tr>
<td>shuffle()</td>
<td>对list集合进行随机排序</td>
</tr>
<tr>
<td>sort(list, [comparatot])</td>
<td>根据指定的Comparator产生的顺序对List集合元素进行排序</td>
</tr>
<tr>
<td>swap(list, int, int)</td>
<td>将指定list集合中的i元素和j元素进行交换</td>
</tr>
<tr>
<td>max(list, comparator)</td>
<td>最大元素</td>
</tr>
<tr>
<td>min(list, comparator)</td>
<td>最小元素</td>
</tr>
<tr>
<td>frequency(list, object)</td>
<td>返回指定元素的出现次序</td>
</tr>
<tr>
<td>replaceAll(list, oldobject, newobject)</td>
<td></td>
</tr>
<tr>
<td>copy(dest, src)</td>
<td>复制</td>
</tr>
</tbody></table>
<hr>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值类型，或者参数类型</p>
<h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><pre><code class="java">class classname&lt;T&gt;&#123;
    ...;
&#125;
</code></pre>
<ul>
<li>普通成员可以使用泛型</li>
<li>使用泛型的数组不能初始化</li>
<li>静态方法中不能使用类的泛型</li>
<li>泛型类的实例是在创建对象时确定的</li>
<li>默认object</li>
</ul>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul>
<li>泛型接口的类型，在继承接口或者实现接口时确定</li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code class="java">public &lt;T, R&gt; void fly(T t, R r)&#123;
    //泛型方法
&#125;
</code></pre>
<ul>
<li>当泛型方法被调用时，类型会确定</li>
</ul>
<h2 id="泛型继承-通配符"><a href="#泛型继承-通配符" class="headerlink" title="泛型继承+通配符"></a>泛型继承+通配符</h2><hr>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2023/03/09/JDBC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ul>
<li>java和数据库必要的纽带</li>
<li>数据库框架底层原理（mybatis…）</li>
<li>api使用路线：<img src="/../imgs/api%E2%80%94%E2%80%94jdbc.png" alt="api"></li>
</ul>
<h1 id="JDBC概念理解"><a href="#JDBC概念理解" class="headerlink" title="JDBC概念理解"></a>JDBC概念理解</h1><ul>
<li>JAVA Database Connectivity - java连接数据库技术<br><img src="/../imgs/JDBC.png" alt="JDBC"></li>
</ul>
<ol>
<li>java.sql.* JDBC接口 对象 &#x3D; 第三方实现类实例</li>
<li>对象.JDBC标准方法()</li>
</ol>
<h1 id="核心api使用"><a href="#核心api使用" class="headerlink" title="核心api使用"></a>核心api使用</h1><ul>
<li>引入mysql-jdbc驱动jar</li>
<li>jdbc基本使用步骤（最好向外抛出异常SQLException）<ul>
<li>注册驱动<blockquote>
<p>对依赖的jar包进行安装</p>
</blockquote>
</li>
</ul>
<pre><code class="java">    DriverManager.registerDriver(new Driver());//8.0版本要带cj的
</code></pre>
<ul>
<li>获取链接<blockquote>
<p>连接数据库的基本信息：ip地址，端口号，账号，密码，连接数据库的名称</p>
</blockquote>
</li>
</ul>
<pre><code class="java">Connection connection= DriverManager.getConnection(url= &quot;jdbc:数据库厂商://ip地址:port/数据库名&quot;, username, password);
</code></pre>
<ul>
<li>创建发送sql语句对象</li>
</ul>
<pre><code class="java">//创建statement
Statement statement = connection.createStatement();
</code></pre>
<ul>
<li>发送sql语句，并获取返回结果</li>
</ul>
<pre><code class="java">String sql = &quot;select * from t_user;&quot;;
ResultSet result = statement.executeQuery(sql);
</code></pre>
<ul>
<li>结果集解析</li>
</ul>
<pre><code class="java">while(resultSet.next())&#123; //是否有下一行数据
    .....   .getInt(columnLabel);
&#125;
</code></pre>
<ul>
<li>资源关闭</li>
</ul>
<pre><code class="java">resultSet.close();
statement.close();
connection.close();
</code></pre>
</li>
</ul>
<h1 id="优化提升"><a href="#优化提升" class="headerlink" title="优化提升"></a>优化提升</h1><ol>
<li>对于注册驱动时的代码优化</li>
</ol>
<pre><code class="java">    DriverManager.registerDriver(new Driver());//8.0版本要带cj的
</code></pre>
<p>问题：在new driver里面和register里面同时定义了驱动，造成浪费</p>
<ul>
<li>直接new Driver()不够灵活：如果说要更改不同数据库的话</li>
<li>最好方案：反射</li>
</ul>
<pre><code class="java">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //可以使用配置文件
</code></pre>
<ol start="2">
<li>获取连接</li>
</ol>
<ul>
<li>两个参数的getConnection(url, properties)</li>
</ul>
<pre><code class="java">Properties info = new Properties();
info.put(&quot;uesr&quot;, &quot;...&quot;);
info.put(&quot;pwd&quot;,&quot;...&quot;);
</code></pre>
<ul>
<li>一个参数<blockquote>
<p>url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbname?username&#x3D;…&amp;password&#x3D;…”;</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>发送sql语句<table>
<thead>
<tr>
<th>SQL分类语句</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>容器创建，修改，删除</td>
</tr>
<tr>
<td>DML</td>
<td>插入修改删除</td>
</tr>
<tr>
<td>DQL</td>
<td>查询</td>
</tr>
<tr>
<td>DCL</td>
<td>权限控制</td>
</tr>
<tr>
<td>TPL</td>
<td>事务控制语言</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li>DML返回影响的行数（int）：比如删除一个数据-&gt;return 1</li>
</ul>
<h1 id="preparedStatement优化"><a href="#preparedStatement优化" class="headerlink" title="preparedStatement优化"></a>preparedStatement优化</h1><ul>
<li>原来的Statement方法存在问题：</li>
</ul>
<ol>
<li>sql语句拼接麻烦</li>
<li>只能拼接字符串类型，其它数据库类型无法处理</li>
<li>可能发生注入攻击：动态值充当sql语句结构</li>
</ol>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java高级</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习笔记</title>
    <url>/2023/03/14/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h1><blockquote>
<p>HTML文档由两部分组成：<br>头部head：可以定义标题，样式<br>主体body标记中可以定义段落，标题字，超链接，脚本，表格，表单…</p>
</blockquote>
<pre><code class="html5">&lt;html&gt;
    文档以&lt;html&gt;标记开始，以&lt;/html&gt;标记开始结束。
    所有html代码都位于这两个标记之间。
    每个html文档都是应该有且只有一个html，head，body元素
&lt;/html&gt;
</code></pre>
<h2 id="头部head"><a href="#头部head" class="headerlink" title="头部head"></a>头部head</h2><p>head标记组成：（head标记所包含信息一般不会显示在网页上）</p>
<ul>
<li>页面标题标记<title></title></li>
<li>元信息标记<mate><ul>
<li>name属性&amp;content属性:描述网页</li>
<li>http-equiv属性 &amp; content属性：提供http响应头报文</li>
</ul>
</li>
<li>样式标记<style></style></li>
<li>标本标记</li>
<li>链接标记</li>
</ul>
<pre><code class="html5">&lt;head&gt;
    &lt;title&gt;这是标题&lt;/title&gt;
    &lt;mate name=&quot;&quot; content=&quot;&quot;&gt;
    &lt;mate http-equiv=&quot;&quot; content=&quot;&quot;&gt;
&lt;/head&gt;
</code></pre>
<h2 id="主体body"><a href="#主体body" class="headerlink" title="主体body"></a>主体body</h2><ul>
<li>body属性可以改变页面的显示结果</li>
<li>topmargin, leftmargin,text, bgcolor, background, link, alink, vlink</li>
</ul>
<pre><code class="html5">&lt;body text = &quot;&quot;, bgcolor = &quot;&quot;&gt;    
&lt;/body&gt;
</code></pre>
<h2 id="html基本语法"><a href="#html基本语法" class="headerlink" title="html基本语法"></a>html基本语法</h2><p>标记类型通常分为单个标记和成对标记</p>
<ul>
<li>单标记</li>
</ul>
<pre><code class="html5">&lt;br&gt;或者&lt;br/&gt;:表示换行
&lt;hr&gt;或者&lt;hr/&gt;:表示水平分割线
&lt;link&gt;:表示链接标记
</code></pre>
<ul>
<li>双标记</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java究极篇</title>
    <url>/2023/03/15/java%E7%A9%B6%E6%9E%81%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><p>通过外部文件配置，再不修改源码情况下来控制程序，也符合设计模式的ocp原则<br>（开闭原则：不修改源码，拓展功能）</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><pre><code class="java">//加载类
Class cls = Class.forName(classfullpath);
//通过cls得到你加载的类的对象实例
Object o = cls.newInstance();
//通过cls得到你加载的类的方法对象
Method method1 = cls.getMethod(methodName);
//通过method1调用方法：即通过方法对象实现调用方法
method1.invoke(o);   //方法.invoke(对象)
field.get(o);       //属性 私有属性不能获取
</code></pre>
<ul>
<li>反射机制允许程序在执行过程中借助ReflectionAPI取得任何类的内部信息，并能操作对象的属性方法。</li>
<li>在设计模式和框架底层都会用到</li>
<li>加载完类后在堆中就产生一个Class类型的对象，这个对象包含类的完整信息结构</li>
<li>这个对象就像一面镜子，透过这个镜子看到类的结构，所以称之为反射</li>
</ul>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ul>
<li>Class也是类，因此也继承Object类</li>
<li>Class类对象不是new出来的，而是系统创建的</li>
<li>对于某个类，在内存中只会加载一份(存放在堆中)<br>获取类的六个阶段：</li>
<li>已知类的全名，可以通过Class.forname()来获取（多用于配置文件）</li>
<li>已知具体类，通过类名.class()获取（多用于参数传递：比如通过反射得到构造器）</li>
<li>已知某个类的实例：Class clazz &#x3D; 对象.getClass()</li>
<li>通过类加载器</li>
</ul>
<pre><code class="java">//获得类加载器
ClassLoader classLoader = car.getClass().getClassLoader();
//获得对象
Class cls = classLoader.loadClass(classAllPath);
</code></pre>
<ul>
<li>基本数据类型 Class cls &#x3D; 基本数据类型.class</li>
<li>Class cls &#x3D; 包装类.TYPE（在java底层包装类型和基本类型会自动装箱拆箱）</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p><img src="/../imgs/threephase.png" alt="class"></p>
<ul>
<li>静态加载: 编译时加载相关的类，如果没有则报错，依赖性太强</li>
<li>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性<br><img src="/../imgs/Classload.png" alt="load"></li>
<li>验证阶段：目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害JVM自身安全<br>文件格式验证，元数据验证，字节码验证和符号引用验证</li>
<li>准备阶段：非静态变量在准备阶段不会分配内存；静态变量会分配内存，默认初始化；常量直接赋值不变</li>
<li>解析阶段：虚拟机将常量池符号引用替换为直接引用（内存地址）</li>
<li>初始化阶段: 真正执行java程序代码，自动收集所有静态变量的赋值动作和静态代码中的语句，并进行合并。</li>
</ul>
<h2 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a>反射获取类的结构信息</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>哪些类型有Class对象</p>
<ul>
<li>外部类，内部成员类，静态内部类，局部内部类，匿名内部类</li>
<li>interface: 接口</li>
<li>数组</li>
</ul>
<pre><code class="java">Class&lt;Integer[]&gt; cls = Integer[].class;
</code></pre>
<ul>
<li>annotation: 注解  </li>
<li>基本数据类型</li>
<li>void</li>
</ul>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><h2 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h2><h2 id="反射相关性能优化"><a href="#反射相关性能优化" class="headerlink" title="反射相关性能优化"></a>反射相关性能优化</h2><ul>
<li>使用反射基本是解释执行，对执行速度有影响<br>解决办法:</li>
<li>关闭访问检查：<blockquote>
<p>Method Field constructor 对象都有setAccessible()方法<br>setAccessible作用是启动和禁用访问安全检查开关<br>参数值为true表示反射的对象在使用时取消访问检查，提高反射效率</p>
</blockquote>
</li>
</ul>
<h2 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h2><p>Class类常用方法：<br><img src="/../imgs/Class%E7%B1%BB.png" alt="method"></p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1>]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实训01</title>
    <url>/2023/07/05/JAVA%E5%AE%9E%E8%AE%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今日知识"><a href="#今日知识" class="headerlink" title="今日知识"></a>今日知识</h1><ul>
<li>jdk安装和配置</li>
<li>java基础补充</li>
<li>javaweb安装和配置</li>
<li>maven安装和配置</li>
<li>框架简介</li>
</ul>
<h1 id="jdk安装和配置"><a href="#jdk安装和配置" class="headerlink" title="jdk安装和配置"></a>jdk安装和配置</h1><ul>
<li><p>JAVA_HOME&#x3D;安装目录</p>
</li>
<li><p>PATH&#x3D;;%JAVA_HOME%&#x2F;bin;</p>
<blockquote>
<p>目的:cmd窗口可以直接使用bin目录下面的可执行文件</p>
</blockquote>
</li>
</ul>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>底层采用可变数组的线性列表</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul>
<li>List<ul>
<li>ArrayList</li>
</ul>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>元素有序,可以重复</p>
<blockquote>
<p>因为底层采用可变数组</p>
</blockquote>
</li>
<li><p>存放的是对象的引用</p>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code class="java">public class ListDemo &#123;
 
    //ArrayList
       //含义:底层采用可变数组的线性集合
       //体系结构
           //List接口
              //ArrayList类
       //注意点
           //集合里面存储的是对象引用 
       
    public static void main(String[] args) &#123;
        User user = new User();
        user.name=&quot;zs&quot;;
        
        
        
        List&lt;User&gt; dataList= new ArrayList&lt;&gt;();
        
        //添加
        dataList.add(user);
        
        //获取
        System.out.println(dataList.get(0));
        
        user.name=&quot;ls&quot;;
        System.out.println(dataList.get(0));
        
        System.out.println(user.name);
        
        //常用的方法
           //add 添加
           //get 获取
           //isEmpty 是否为空
           //size 元素的个数
           //contains 是否包含
           //remove 删除
        
        List&lt;String&gt; nameList = new ArrayList&lt;&gt;();
        
        nameList.add(&quot;zs&quot;);
        nameList.add(&quot;ls&quot;);
        
        System.out.println(nameList.get(0));    //zs
        
        System.out.println(nameList.isEmpty()); //false
        
        System.out.println(nameList.size());    //2
        System.out.println(nameList.contains(&quot;ww&quot;));  //false
        
        nameList.remove(0);
        
        System.out.println(nameList); //ls
    &#125;
&#125;
class User&#123;
    
    public String name;

    @Override
    public String toString() &#123;
        return &quot;User [name=&quot; + name + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p>输入输出</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>游戏分数</li>
<li>数据传输</li>
<li>文件保存</li>
<li>等等</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>方向</p>
<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
</li>
<li><p>传输的单位</p>
<ul>
<li><p>字符流</p>
</li>
<li><p>字节流</p>
</li>
</ul>
</li>
</ul>
<h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>字节输入流</p>
<pre><code class="java">public class _01IODemo &#123;
    
    //参照物
        //程序本身
    
    //字节流
       //含义:代表我们操作的是字节
    //字符流
       //含义:代表我们操作的是字符
    
    //read write close(释放) flush
    
    public static void main(String[] args) &#123;
        //字节输入流
        
        //abstract
        InputStream inputStream = null;
        try &#123;
            inputStream = new FileInputStream(&quot;D:\\11.txt&quot;);
         
        
            
            //读取一个字节并打印
            //int data = inputStream.read();
            //System.out.println(data);
         
        
            //循环读取一个字节并打印
            /*
            int len = -1;
            while((len=inputStream.read())!=-1)&#123;
                System.out.println((char)len);
            &#125;
            */
            
            /*
            byte [] cache = new byte[3];
            
            int len = -1;
            
            //len代表读取到的字节个数
            len = inputStream.read(cache);//[97,98,99]
            System.out.println(new String(cache));//
            

            len = inputStream.read(cache);//[100,98,99]
            System.out.println(len);
            
            //String(byte bytes[], int offset, int length)
            System.out.println(new String(cache,0,len));//dbc
             
            */
            
            
            byte [] cache = new byte[3];
            int len =-1;
            while((len=inputStream.read(cache))!=-1)&#123;
                System.out.println(new String(cache,0,len));
            &#125;
        &#125;catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //不管有没有异常都会执行
            if(inputStream!=null)&#123;
                try &#123;
                    inputStream.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>字节输出流</p>
<pre><code class="java">public class _02IODemo &#123;
    //字节输出流
    
    //close flush read write
    public static void main(String[] args) &#123;
        String content = &quot;abc&quot;;
        
        OutputStream outputStream = null;
        try &#123;
            outputStream = new FileOutputStream(&quot;D:\\22.txt&quot;);
             
            //一个一个字节输出
            //outputStream.write(97);
            //outputStream.write(98);
            //outputStream.write(99);
            
            outputStream.write(content.getBytes());
            
            
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(outputStream!=null)&#123;
                try &#123;
                    outputStream.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;	
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h2><p>字符输入和输出流</p>
<pre><code class="java">/**
 * 
 * @author Administrator
 *
 */
public class _03IODemo &#123;
    
    //字节流
       //特点:XXStream结尾
    //字符流
       //特点:XXReader || XXWriter 结尾
 
 
    /**
     * 
     * @param args
     */
    public static void main(String[] args) &#123;
         
        //readDataByChar();
        
        writeDataByChar();
    &#125;
    
    private static void writeDataByChar()&#123;
        
        Writer writer = null;
        try &#123;
            writer = new FileWriter(&quot;D:\\a.txt&quot;);
            
            //输出的内容来自控制台
            //System.in标准输入流【控制台】
            
            System.out.println(&quot;请输入要保存的内容&quot;);
            Scanner scanner = new Scanner(System.in);
            String content = scanner.nextLine();
            
            
            writer.write(content);
            
            
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(writer!=null)&#123;
                try &#123;
                    writer.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        
    &#125;
 
    
    /**
     * 字符输入流案例
     */
    private static void readDataByChar()&#123;
        
        //字符流
        
        Reader reader=null;
        try &#123;
            reader = new FileReader(&quot;D:\\a.txt&quot;);
            
            
            //读取一个字符
            //System.out.println((char)reader.read());
             
            //循环读取字符
            /*
            int len = -1;
            while((len=reader.read())!=-1)&#123;
                System.out.println((char)len);
            &#125;
            */
            
            /*
            char [] cache = new char[3];//中国加
            int len = -1;
            
            len = reader.read(cache);   //3
            
            System.out.println(len);
            System.out.println(new String(cache,0,len));
            
            
            
            len = reader.read(cache);   //油国加
            
            System.out.println(len);    //1
            System.out.println(new String(cache,0,len)); //油国加
            */
            
            //含义:字符串的拼接(append)类
            StringBuilder SB = new StringBuilder();
            
            char [] cache = new char[3];//中国加
            int len = -1;
            
            while((len=reader.read(cache))!=-1)&#123;
                //System.out.println(new String(cache,0,len)); 
                SB.append(new String(cache,0,len));
            &#125;
            
            System.out.println(SB);
            
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(reader!=null)&#123;
                try &#123;
                    reader.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        
    &#125;
&#125;
</code></pre>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h2><ul>
<li>jdk提供的类</li>
<li>file对象代表一个文件或文件夹</li>
</ul>
<h2 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h2><p>File入门</p>
<pre><code class="java">public class FileDemo &#123;
    
    //File
      //含义
          //jdk提供的类
          //一个File对象代表一个文件或文件夹
    
    public static void main(String[] args) &#123;
        
        File file = new File(&quot;D:\\暨南大学\\Day01&quot;);
        
        
        //false
        System.out.println(file.isFile());
        //true
        System.out.println(file.isDirectory());
        
        File children [] = file.listFiles();
             //
        for(File child : children)&#123;
            
            System.out.println(child.getName());
            System.out.println(child.getAbsolutePath());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h2><p>文件递归</p>
<pre><code class="java">/**
 * 
 * @author Administrator
 *
 */
public class FileOtherDemo &#123;
    
    //罗列出D:\暨南大学\Day01文件夹下的所有视频名字
    
    //递归
       //含义:有限次数自己调用自己
       //注意点:递归次数【深度】太多【太深】会造成栈溢出[StackOverflowError]

    //方法的调用其实就是方法的入栈和出栈的过程
    
    
    
    public static void main(String[] args) &#123;
        
        
        
        String parentPath = &quot;D:\\暨南大学\\Day01&quot;;
        listVideoName(parentPath);
     
    &#125;
    
    /**
     * 列出当前路径所在的视频名称和孩子文件夹的视频名称
     * @param parentPath
     */
    private static void listVideoName(String parentPath)&#123;
        
        if(parentPath==null || &quot;&quot;.equals(parentPath.trim()))&#123;
            return;
        &#125;
        
        //罗列出当前路径下的视频名称
        File parentFile = new File(parentPath);
        
        File children [] = parentFile.listFiles();
        
        for(File child : children)&#123;
            
            //判断是不是MP4视频格式
            if(child.isFile())&#123;
                if(child.getName().endsWith(&quot;.mp4&quot;) )&#123;
                    System.out.println(child.getName());
                &#125;
            &#125;else&#123;
                //文件夹
                listVideoName(child.getAbsolutePath());
            &#125;
            
        &#125;
        
    &#125;
&#125;
</code></pre>
<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p> <img src="/../imgs/1688544024834.png" alt="1688544024834"></p>
<h2 id="案例一-2"><a href="#案例一-2" class="headerlink" title="案例一"></a>案例一</h2><p>字符输出缓冲流</p>
<pre><code class="java">public class BufferedDemo &#123;
    
    public static void main(String[] args) &#123;
        
        //缓冲流
           //含义:内部有缓冲区,读取数据的时候是从缓冲区里面读取的。写出数据是先写到缓冲区
                                                            //缓冲区里面的数据什么时候会刷新【输出】到磁盘文件中?
                                                                 //缓冲区满了;//flush;//close
        

        //字符输出缓冲流
        Writer writer=null;
        BufferedWriter bufferedWriter=null;
        try &#123;
            writer = new FileWriter(&quot;D:\\c.txt&quot;);
            bufferedWriter = new BufferedWriter(writer);
            
            bufferedWriter.write(&quot;abcd&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(bufferedWriter!=null)&#123;
                try &#123;
                    bufferedWriter.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="案例二-2"><a href="#案例二-2" class="headerlink" title="案例二"></a>案例二</h2><p>字符输入缓冲流</p>
<pre><code class="java">public class BufferedOtherDemo &#123;
    
    public static void main(String[] args) &#123;
        
        //字符输入缓冲流
        Reader reader=null;
        BufferedReader bufferedReader=null;
        try &#123;
            reader = new FileReader(&quot;D:\\c.txt&quot;);
            bufferedReader = new BufferedReader(reader);
            
            String content = null;
            
            while((content=bufferedReader.readLine())!=null)&#123;
                
                System.out.println(content);
            &#125;
            
            
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(bufferedReader!=null)&#123;
                try &#123;
                    bufferedReader.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="代码统计"><a href="#代码统计" class="headerlink" title="代码统计"></a>代码统计</h1><pre><code class="java">public class Test &#123;
    
    static int sum=0;
    public static void main(String[] args) &#123;
        
        String targetPath = &quot;C:\\Users\\Administrator\\workspace&quot;;
        
        //统计多少行代码? 
           //思路
              //找到所有的.java文件
              //读取.java文件有多少行
              //累加
        
        listJavaFile(targetPath);
        System.out.println(sum);
    &#125;
    
    /**
     * 递归读取java文件
     * @param parentPath
     */
    private static void listJavaFile(String parentPath)&#123;
        if(parentPath==null || &quot;&quot;.equals(parentPath.trim()))&#123;
            return;
        &#125;
        
        File parentFile = new File(parentPath);
        
        //罗列孩子
        File children [] = parentFile.listFiles();
        
        for(File child : children)&#123;
            
            if(child.isFile())&#123;
                //是不是java文件
                if(child.getName().endsWith(&quot;.java&quot;))&#123;
                    //是java文件 TODO
                    int count = calCount(child.getAbsolutePath());
                    sum+=count;
                &#125;
            &#125;else&#123;
                //文件夹
                listJavaFile(child.getAbsolutePath());
            &#125;
        &#125;
    &#125;


    /**
     * 读取某一个java文件的代码行数
     * @param path
     */
    private static int calCount(String path)&#123;
        int count = 0;
         
        BufferedReader bufferedReader=null;
        try &#123;
            bufferedReader = new BufferedReader(new FileReader(path));
            
            //读一行加1
            String content = null;
            while((content=bufferedReader.readLine())!=null)&#123;
                if(!&quot;&quot;.equals(content.trim()))&#123;
                    count++;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(bufferedReader!=null)&#123;
                try &#123;
                    bufferedReader.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
&#125;
</code></pre>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre><code class="java">public class Server &#123;
    
    public static void main(String[] args) &#123;
        
        ServerSocket serverSocket = null;
        try &#123;
            serverSocket = new ServerSocket(8080);
            
            System.out.println(&quot;等待客户端连接&quot;);
            
            //等待[阻塞]连接
            Socket socket = serverSocket.accept();
            
        
            System.out.println(&quot;有客户端连接了&quot;);
            //有客户端连接了
            
            //读取客户端发送过来的数据【输入流】
            InputStream inputStream = socket.getInputStream();
            
            byte [] cache = new byte[1024];
            int len = -1;
            
            StringBuilder content = new StringBuilder();
            //while((len=inputStream.read(cache))!=-1)&#123;
                len=inputStream.read(cache);
                content.append(new String(cache,0,len));
            //&#125;
            
            System.out.println(&quot;收到客户端的内容&quot;+content.toString());
            
            
            //响应数据给客户端【输出流】
            OutputStream outputStream = socket.getOutputStream();
            outputStream.write(content.toString().getBytes());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(serverSocket!=null)&#123;
                try &#123;
                    serverSocket.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre><code class="java">public class Client &#123;
    
    public static void main(String[] args) &#123;
        //localhost 127.0.0.1 代表本机
        
        Socket socket=null;
        try &#123;
            socket = new Socket(&quot;localhost&quot;, 8080);
            
            String content = &quot;hello world&quot;;
            
            //发送到服务器【输出流】
            OutputStream outputStream = socket.getOutputStream();
            outputStream.write(content.getBytes());
         
            
            //获取到服务器响应回来的数据【输入流】
            
            InputStream inputStream = socket.getInputStream();
            StringBuilder SB = new StringBuilder();
            
            int len = -1;
            byte [] cache = new byte[1024];
            //while((len=inputStream.read(cache))!=-1)&#123;
            	len=inputStream.read(cache);
                SB.append(new String(cache,0,len));
            //&#125;
            
            System.out.println(&quot;服务器响应的内容:&quot;+SB.toString());
            
            
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(socket!=null)&#123;
                try &#123;
                    socket.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<h1 id="javaweb安装和配置"><a href="#javaweb安装和配置" class="headerlink" title="javaweb安装和配置"></a>javaweb安装和配置</h1><p>TODO</p>
<h1 id="maven安装和配置"><a href="#maven安装和配置" class="headerlink" title="maven安装和配置"></a>maven安装和配置</h1><p>TODO</p>
<h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p>TODO</p>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java实训</tag>
        <tag>DAY1</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实训02</title>
    <url>/2023/07/06/JAVA%E5%AE%9E%E8%AE%AD02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre><code class="java">package com.neu.server.manager;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class ServerManager &#123;
    
    public static void main(String[] args) &#123;
        
        //Server
            //开发步骤
               //创建ServerSocket 并绑定监听端口
               //等待客户端连接【accept】
               //获取到和客户端通信的Socket对象
        
        ServerSocket serverSocket=null;
        try &#123;
            serverSocket = new ServerSocket(8080);
            
            //等待客户端连接【阻塞】
            System.out.println(&quot;等待客户端连接&quot;);
            Socket socket = serverSocket.accept();
            
            InputStream inputStream = socket.getInputStream();
            
            OutputStream outputStream = socket.getOutputStream();
            //转换流
            //InputStreamReader reader = new InputStreamReader(inputStream);
            //OutputStreamWriter writer = new OutputStreamWriter(outputStream);
            
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            
            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
            
            //请求 request
            //响应 response
            
            //读取一行,然后响应给客户端
            
            String content = bufferedReader.readLine();//\r\n
            
            //bufferedWriter.write(content+&quot;\r\n&quot;);
            bufferedWriter.write(content);
            //响应换行标示
            bufferedWriter.newLine();
            bufferedWriter.flush();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if(serverSocket!=null)&#123;
                try &#123;
                    serverSocket.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre><code class="java">public class ChatView extends JFrame implements ActionListener&#123;
    
    //布局管理器
        //含义:控制组件该如何摆放
        //常见
           //边界布局管理器
                //含义:JFrame默认的布局管理器,分成上北下南左西右东中间是center区域
           //流式布局管理器
           //网格布局管理器
           //卡片布局管理器
           //....

    private JPanel bottomJPanel;
    private JTextField contentJTextField;
    private JButton sendJButton;
    
    private JTextArea chatLog;
    
    //图形界面
       //步骤
          //extends JFrame [窗口]
          //设置
              //设置标题、大小、位置、是否可见、、关闭的默认行为、内容
    
    
    private Socket socket;
    private BufferedWriter bufferedWriter;
    
    public ChatView()&#123;
        setTitle(&quot;聊天界面&quot;);
        setBounds(0, 0, 400, 300);
        
        
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        chatLog = new JTextArea(10, 20);
        chatLog.setEditable(false);
         
        
        bottomJPanel = new JPanel();  //面板默认的布局管理器是流式布局
        
        contentJTextField = new JTextField(20);
        sendJButton = new JButton(&quot;发送&quot;);
        //绑定点击事件
        sendJButton.addActionListener(this);//ActionListener
        
        bottomJPanel.add(contentJTextField);
        bottomJPanel.add(sendJButton);
        
        
        setLayout(new BorderLayout());
        
        add(bottomJPanel,  BorderLayout.SOUTH);
        add(chatLog,  BorderLayout.CENTER);
        
        setVisible(true);
        
        //连接服务器
        try &#123;
            socket = new Socket(&quot;127.0.0.1&quot;,8080);
            
            OutputStream outputStream = socket.getOutputStream();
            bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
            
            //输入流
            InputStream inputStream = socket.getInputStream();
            
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            String responseContent = bufferedReader.readLine();
            
            chatLog.append(responseContent+&quot;\r\n&quot;);
        &#125; catch (UnknownHostException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
    public static void main(String[] args) &#123;
        
        ChatView chatView = new ChatView();
        
    &#125;

    @Override
    public void actionPerformed(ActionEvent event) &#123;
        //事件源【事件在哪个组件发送】
        Object source =  event.getSource();
        if(source==sendJButton)&#123;
            //获取输入的内容
            String content = contentJTextField.getText();
            
            //发送出去
            //bufferedWriter.write(content+&quot;\r\n&quot;);
            try &#123;
                bufferedWriter.write(content);
                bufferedWriter.newLine();
                bufferedWriter.flush();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p>进程</p>
<blockquote>
<p>含义:一个正在运行的软件【程序】</p>
</blockquote>
</li>
<li><p>线程</p>
<ul>
<li>一个进程至少要有一个线程</li>
<li>任务分支索引</li>
</ul>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>耗时的操作</li>
<li>网络通信</li>
<li>多线程文件下载</li>
</ul>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul>
<li>extends Thread</li>
<li>implement Runnable</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>getId</p>
</li>
<li><p>getName</p>
</li>
<li><p>Thread.currentThread</p>
</li>
<li><p>Thread.sleep</p>
</li>
<li><p>run</p>
<blockquote>
<p>设置线程的任务</p>
</blockquote>
</li>
<li><p>start</p>
<blockquote>
<p>启动线程</p>
</blockquote>
</li>
</ul>
<h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><pre><code class="java">public class _01Thread &#123;
    //进程
       //含义:一个正在运行的软件【程序】
    //线程
       //含义:任务分支【索引】
       //注意点
          //一个进程至少要求有一个线程
    
    //常用的api
       //Thread.currentThread 获取当前线程对象
       //getName
       //getId
    
    //方式
       //extends Thread
            //重写run方法【含义:指定线程的任务】
            //创建线程对象
            //调用线程对象.start() 【含义:启动】
       //implements Runnable
    
    public static void main(String[] args) &#123;
        
        /*
        Thread thread = Thread.currentThread();
        System.out.println(thread.getId());
        System.out.println(thread.getName());
        System.out.println(thread);
        */
        
        //创建线程对象
        Thread leftThread = new LeftThread();
        leftThread.start();
        
        Thread rightThread = new RightThread();
        rightThread.start();
        
        System.out.println(&quot;main&quot;);
    &#125;
&#125;

class LeftThread extends Thread&#123;
    @Override
    public void run() &#123;
     System.out.println(&quot;画圆&quot;);
    &#125;
&#125;

class RightThread extends Thread&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;画正方形&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><pre><code class="java">public class _02Thread &#123;
    
    public static void main(String[] args) &#123;
        
        Runnable draw = new Draw();
        Thread thread = new Thread(draw);
        
        thread.start();
        
        
        for(int i=0;i&lt;10;i++)&#123;
            System.out.println(&quot;maini=&quot;+i);
        &#125;
    &#125;

&#125;

class Draw implements Runnable&#123;
    

    /**
     * 指定任务
     */
    @Override
    public void run() &#123;
        
        int count = 10;
        for(int i=0;i&lt;count;i++)&#123;
            System.out.println(&quot;子线程i=&quot;+i);
        &#125;
        
    &#125;
&#125;
</code></pre>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><ul>
<li>线程安全</li>
<li>线程池</li>
</ul>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>servlet的容器</p>
<blockquote>
<p>servlet是用来处理请求产生响应的java类</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>CATALINA_HOME&#x3D;解压目录</li>
<li>PATH&#x3D;;%CATALINA_HOME%\bin;</li>
</ul>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ul>
<li>启动<ul>
<li>cmd下面输入startup.bat</li>
<li>bin目录下面直接双击startup.bat</li>
</ul>
</li>
<li>关闭<ul>
<li>直接关闭窗口</li>
<li>cmd下面输入shutdown.bat</li>
<li>bin目录下面直接双击shutdown.bat</li>
</ul>
</li>
</ul>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><a href="http://localhost:8080/">http://localhost:8080</a></p>
<h1 id="关联tomcat"><a href="#关联tomcat" class="headerlink" title="关联tomcat"></a>关联tomcat</h1><ul>
<li><p>步骤一</p>
<p> <img src="/../imgs/1688624168623.png" alt="1688624168623"></p>
</li>
<li><p>步骤二</p>
<p> <img src="/../imgs/1688624207305.png" alt="1688624207305"></p>
</li>
<li><p>步骤三</p>
<p> <img src="/../imgs/1688624247344.png" alt="1688624247344"></p>
</li>
<li><p>步骤四</p>
<p> <img src="/../imgs/1688624305169.png" alt="1688624305169"></p>
</li>
<li><p>步骤五</p>
<p><img src="/../imgs/1688624498609.png" alt="1688624498609"></p>
</li>
</ul>
<h1 id="创建web项目"><a href="#创建web项目" class="headerlink" title="创建web项目"></a>创建web项目</h1><ul>
<li><p>步骤一</p>
<p> <img src="/../imgs/1688624733856.png" alt="1688624733856"></p>
</li>
<li><p>步骤二</p>
<p> <img src="/../imgs/1688624781275.png" alt="1688624781275"></p>
</li>
<li><p>步骤三</p>
<p> <img src="/../imgs/1688624879727.png" alt="1688624879727"></p>
</li>
</ul>
<h1 id="web项目结构"><a href="#web项目结构" class="headerlink" title="web项目结构"></a>web项目结构</h1><p> <img src="/../imgs/1688640797040.png" alt="1688640797040"></p>
<h1 id="部署web项目"><a href="#部署web项目" class="headerlink" title="部署web项目"></a>部署web项目</h1><ul>
<li><p>步骤一</p>
<p> <img src="/../imgs/1688625085552.png" alt="1688625085552"></p>
</li>
<li><p>步骤二</p>
<p> <img src="/../imgs/1688625132678.png" alt="1688625132678"></p>
</li>
<li><p>步骤三</p>
<p> <img src="/../imgs/1688625196674.png" alt="1688625196674"></p>
</li>
</ul>
<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p>用来处理请求产生响应的tomcat提供的java类</p>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ul>
<li><p>extends HttpServlet</p>
</li>
<li><p>重写doGet或doPost方法</p>
</li>
<li><p>配置</p>
<ul>
<li><p>基于注解配置</p>
<blockquote>
<p>语法:@WebServlet(“&#x2F;请求路径”)</p>
</blockquote>
</li>
<li><p>基于web.xml配置</p>
<blockquote>
<p>TODO</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>index.html</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form method=&quot;post&quot; action=&quot;/WebDay01/hello&quot;&gt;
      &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;
  
      &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt;
      
      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;br/&gt;
  &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>HelloServlet.java</p>
<pre><code class="java">@WebServlet(&quot;/hello&quot;)
public class HelloServlet extends HttpServlet&#123;
    
    //Servlet
        //含义:用来处理请求产生响应的java类
        //开发步骤
            //extends HttpServlet
            //重写doGet || doPost
            //配置
                //web.xml
                //注解方式
                    //@WebServlet
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        String content = &quot;hello java&quot;;
        resp.getOutputStream().write(content.getBytes());
    
    &#125;
    
    /**
     * 处理post请求的 
     */
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        
        //请求
           //含义:包含请求的全部信息
           //组成[了解]
                //请求行
                     //请求路径、请求协议和版本、请求的方式
                //请求头
                     //含义:用来描述请求的额外信息
                     //getHeader
                //请求体
                     //用来携带请求参数的,
                     //get请求没有请求体,他的参数拼接在url后面
                     //post请求有请求体
        
        String url = req.getRequestURL().toString();
        System.out.println(&quot;url=&quot;+url);
        
        String protocol = req.getProtocol();
        System.out.println(&quot;protocol=&quot;+protocol);
        
        String method = req.getMethod();
        System.out.println(&quot;method=&quot;+method);
         
        //获取请求参数
        String name = req.getParameter(&quot;name&quot;);
        String pwd = req.getParameter(&quot;pwd&quot;);
        
        //响应[不能同时使用,否则会报错]
           //方式一:resp.getOutputStream();  //字节流,文件下载
           //方式二:PrintWriter printWriter = resp.getWriter();//字符流,响应文本
           
        PrintWriter printWriter = resp.getWriter();
        printWriter.print(&quot;name=&quot;+name);
        printWriter.print(&quot;pwd=&quot;+pwd);
    &#125;
&#125;
</code></pre>
<h1 id="示意图一"><a href="#示意图一" class="headerlink" title="示意图一"></a>示意图一</h1><p> <img src="/../imgs/1688629881569.png" alt="1688629881569"></p>
<h1 id="示意图二"><a href="#示意图二" class="headerlink" title="示意图二"></a>示意图二</h1><p> <img src="/../imgs/1688629915781.png" alt="1688629915781"></p>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h2><p>java提供的一套用于操作数据库的规范,不同的数据库厂商实现该规范并打成一个jar包【即:数据库驱动】</p>
<h2 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h2><ul>
<li><p>导入驱动包</p>
</li>
<li><p>编写代码</p>
<ul>
<li><p>注册驱动</p>
<blockquote>
<p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p>
</blockquote>
</li>
<li><p>获取连接对象</p>
<blockquote>
<p>Connection conn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;主机:端口&#x2F;数据库名”,”账号”,”密码”);</p>
</blockquote>
</li>
<li><p>获取操作数据库对象</p>
<blockquote>
<p>PreparedStatment preparedStatment &#x3D; conn.prepareStatment(“sql语句”);</p>
<p>设置占位符参数</p>
<p>preparedStatment.setXX(第几个占位符参数,从1开始,参数值);、</p>
</blockquote>
</li>
<li><p>释放资源</p>
<blockquote>
<p>ResultSet、PreparedStament、Connection对象的close方法</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre><code class="sql">SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(40) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `pwd` varchar(40) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&#x2F;WebContent&#x2F;register.html</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form method=&quot;post&quot; action=&quot;/WebDay01/register&quot;&gt;
      &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;
  
      &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt;
      
      &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;br/&gt;
  &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>RegisterController.java</p>
<pre><code class="java">public class RegisterServlet extends HttpServlet&#123;
    
    //注册
        //注解
        //web.xml 【WEB-INF/web.xml】 
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

        //获取请求参数
        String name = req.getParameter(&quot;name&quot;);
        String pwd = req.getParameter(&quot;pwd&quot;);
        
        
        UserService userService = new UserServiceImpl();
        int result = userService.add(name, pwd);
        if(result==1)&#123;
            resp.getWriter().print(&quot;success&quot;);
        &#125;else&#123;
            resp.getWriter().print(&quot;failure&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>UserService.java</p>
<pre><code class="java">public interface UserService &#123;

    int add(String name,String pwd);
&#125;
</code></pre>
<p>UserServiceImpl.java</p>
<pre><code class="java">public class UserServiceImpl implements UserService&#123;

    /**
     * 添加用户
     * @return 返回添加成功的记录
     */
    @Override
    public int add(String name, String pwd) &#123;
        //调用dao
        
        UserDao userDao = new UserDaoImpl();
        return userDao.add(name, pwd);
    &#125;
&#125;
</code></pre>
<p>UserDao.java</p>
<pre><code class="java">public interface UserDao &#123;
   int add(String name,String pwd);
&#125;
</code></pre>
<p>UserDaoImpl.java</p>
<pre><code class="java">public class UserDaoImpl implements UserDao&#123;

    @Override
    public int add(String name, String pwd) &#123;
     
        //操作数据库
        Connection conn = JDBCUtil.getConn();
        
        String sql = &quot;insert into t_user(name,pwd) values(?,?)&quot;;
        
        //操作数据库对象【执行sql语句】
        PreparedStatement preparedStatement=null;
        try &#123;
            preparedStatement = conn.prepareStatement(sql);
            //设置占位符参数值
            preparedStatement.setString(1, name);
            preparedStatement.setString(2, pwd);
            
            //发送【执行】sql语句,返回的是所影响的记录数
            return preparedStatement.executeUpdate();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
            return -1;
        &#125;finally &#123;
            JDBCUtil.close(null, preparedStatement, conn);
        &#125;
    &#125;
&#125;
</code></pre>
<p>JDBCUtil.java</p>
<pre><code class="java">public class JDBCUtil &#123;

    // 注册驱动
       // 一次就好
     
    //静态代码块,这里面的代码只会执行一次
    static &#123;
        try &#123;
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     * 获取连接对象
     * 
     * @return
     */
    public static Connection getConn() &#123;
        try &#123;
            return DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jida&quot;, &quot;root&quot;, &quot;sdcx123456,&quot;);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;

    
    /**
     * 释放资源
     * @param resultSet
     * @param preparedStatement
     * @param conn
     */
    public static void close(ResultSet resultSet, PreparedStatement preparedStatement, Connection conn) &#123;
        try &#123;
            if (resultSet != null) &#123;
                resultSet.close();
            &#125;
            if (preparedStatement != null) &#123;
                preparedStatement.close();
            &#125;
            if (conn != null) &#123;
                conn.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
  version=&quot;3.1&quot;
  metadata-complete=&quot;false&quot;&gt;
  
  &lt;!-- serlvet --&gt;
  &lt;servlet&gt;
     &lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt;
     &lt;!-- 全限定名,按ctrl + 鼠标左键检查 --&gt;
     &lt;servlet-class&gt;com.neu.day01.servet.RegisterServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/register&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h1 id="maven安装和配置"><a href="#maven安装和配置" class="headerlink" title="maven安装和配置"></a>maven安装和配置</h1><p>TODO</p>
<h1 id="常见坐标"><a href="#常见坐标" class="headerlink" title="常见坐标"></a>常见坐标</h1><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.28&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p>TODO</p>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java实训</tag>
        <tag>DAY2</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实训04</title>
    <url>/2023/07/08/JAVA%E5%AE%9E%E8%AE%AD04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今日知识点"><a href="#今日知识点" class="headerlink" title="今日知识点"></a>今日知识点</h1><ul>
<li>Mapper接口实现CRUD</li>
<li>动态SQL</li>
<li>Spring框架介绍</li>
<li>ApplicationContext</li>
</ul>
<p>添加依赖</p>
<p>编写配置文件</p>
<p>代码编写</p>
<h1 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>保户</li>
<li>增强</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul>
<li>静态代理</li>
<li>动态代理<ul>
<li>JDK动态代理</li>
<li>CGLib动态代理</li>
</ul>
</li>
</ul>
<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li>目标类要实现接口</li>
</ul>
<h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p> <img src="/../imgs/assets04/1688781163488.png" alt="1688781163488"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>Star.java</p>
<pre><code class="java">public interface Star &#123;
    void sign(int money);
&#125;
</code></pre>
<p>LDH.java</p>
<pre><code class="java">public class LDH implements Star&#123;
    @Override
    public void sign(int money) &#123;
        if(money==2000)&#123;
            System.out.println(&quot;冰雨&quot;);
        &#125;else if(money&gt;2000)&#123;
            System.out.println(&quot;爱你一万年&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>Fans.java</p>
<pre><code class="java">public class Fans &#123;

    public static void main(String[] args) &#123;

        //为什么要用代理对象
            //第一:保护目标
            //第二:增强

        //技术方案
            //静态代理
            //动态代理
               //jdk动态代理
                  //要求:目标要实现接口
                  //接口和类
                      //Proxy
                      //InvocationHandler

               //cglib动态代理

        //LDH ldh = new LDH();
        //ldh.sign(1000000);

        //Proxy.newProxyInstance(类加载器,目标实现的接口数组,调用代理对象方法的回调);

        InvocationHandler invocationHandler = new MyInvocationHandler();
        Star proxy = (Star) Proxy.newProxyInstance(Fans.class.getClassLoader(),
                LDH.class.getInterfaces(),invocationHandler);
        proxy.sign(10000);
    &#125;

&#125;

class MyInvocationHandler implements InvocationHandler&#123;

    LDH target = new LDH();

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;

        //System.out.println(method.getName());
        //System.out.println(args[0]);

        System.out.println(&quot;布置场地&quot;);
        Object result =  method.invoke(target,args);
        System.out.println(&quot;清理场地&quot;);
        return result;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java实训</tag>
        <tag>DAY4</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实训03</title>
    <url>/2023/07/08/JAVA%E5%AE%9E%E8%AE%AD03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h1><ul>
<li>网上下载jar包麻烦</li>
<li>jar包版本更新也麻烦</li>
</ul>
<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>构建项目的工具</p>
<h2 id="示意图一"><a href="#示意图一" class="headerlink" title="示意图一"></a>示意图一</h2><p> <img src="/../imgs/assets03/1688690979059.png" alt="1688690979059"></p>
<h2 id="示意图二"><a href="#示意图二" class="headerlink" title="示意图二"></a>示意图二</h2><p> <img src="/../imgs/assets03/1688690950869.png" alt="1688690950869"></p>
<h2 id="maven安装和配置"><a href="#maven安装和配置" class="headerlink" title="maven安装和配置"></a>maven安装和配置</h2><ul>
<li><p>解压</p>
</li>
<li><p>配置</p>
<blockquote>
<p>MAVEN_HOME&#x3D;解压目录</p>
<p>PATH&#x3D;;%MAVEN_HOME%\bin;</p>
</blockquote>
</li>
<li><p>验证</p>
<blockquote>
<p>mvn -v</p>
</blockquote>
</li>
</ul>
<h1 id="maven关键名词"><a href="#maven关键名词" class="headerlink" title="maven关键名词"></a>maven关键名词</h1><ul>
<li><p>仓库</p>
<blockquote>
<p>用来存放资源的【jar等资源】</p>
<p>本地仓库</p>
<p>中央【远程】仓库</p>
</blockquote>
</li>
<li><p>pom文件 (pom.xml),每一个maven项目都有一个pom文件,这是核心文件</p>
<blockquote>
<p>描述当前项目的依赖信息</p>
</blockquote>
</li>
<li><p>groupId 用来划分项目的。一般就是包名</p>
</li>
<li><p>artifactId 代表项目名</p>
</li>
<li><p>package </p>
<ul>
<li>代表打包类型,比如:jar\war\pom(如果是pom一般都是父项目)</li>
</ul>
</li>
</ul>
<h1 id="settings-xml"><a href="#settings-xml" class="headerlink" title="settings.xml"></a>settings.xml</h1><ul>
<li><p><strong>localRepository配置本地仓库</strong></p>
<pre><code class="xml">&lt;localRepository&gt;D://work/repo&lt;/localRepository&gt;
</code></pre>
</li>
<li><p><strong>mirrors 配置镜像,可以设置远程仓库为国内站点</strong></p>
<pre><code class="xml">&lt;mirror&gt;
    &lt;id&gt;alimaven&lt;/id&gt;
    &lt;name&gt;aliyun maven&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       
&lt;/mirror&gt;
</code></pre>
</li>
<li><p><strong>profiles 额外设置</strong></p>
<pre><code class="xml">&lt;profile&gt;
  &lt;id&gt;jdk-1.8&lt;/id&gt;
  &lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;jdk&gt;1.8&lt;/jdk&gt;
  &lt;/activation&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
  &lt;/properties&gt;
&lt;/profile&gt;
</code></pre>
</li>
<li><p><strong>activeProfiles 激活设置</strong></p>
<pre><code class="xml">&lt;activeProfile&gt;jdk-1.8&lt;/activeProfile&gt;
</code></pre>
</li>
</ul>
<h2 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
--&gt;

&lt;!--
 | This is the configuration file for Maven. It can be specified at two levels:
 |
 |  1. User Level. This settings.xml file provides configuration for a single user,
 |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -s /path/to/user/settings.xml
 |
 |  2. Global Level. This settings.xml file provides configuration for all Maven
 |                 users on a machine (assuming they&#39;re all using the same Maven
 |                 installation). It&#39;s normally provided in
 |                 $&#123;maven.conf&#125;/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -gs /path/to/global/settings.xml
 |
 | The sections in this sample file are intended to give you a running start at
 | getting the most out of your Maven installation. Where appropriate, the default
 | values (values used when the setting is not specified) are provided.
 |
 |--&gt;
&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  &lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: $&#123;user.home&#125;/.m2/repository
  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;
  --&gt;
  &lt;localRepository&gt;D:\work\repo&lt;/localRepository&gt;

  &lt;!-- interactiveMode
   | This will determine whether maven prompts you when it needs input. If set to false,
   | maven will use a sensible default value, perhaps based on some other setting, for
   | the parameter in question.
   |
   | Default: true
  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;
  --&gt;

  &lt;!-- offline
   | Determines whether maven should attempt to connect to the network when executing a build.
   | This will have an effect on artifact downloads, artifact deployment, and others.
   |
   | Default: false
  &lt;offline&gt;false&lt;/offline&gt;
  --&gt;

  &lt;!-- pluginGroups
   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.
   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers
   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.
   |--&gt;
  &lt;pluginGroups&gt;
    &lt;!-- pluginGroup
     | Specifies a further group identifier to use for plugin lookup.
    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;
    --&gt;
  &lt;/pluginGroups&gt;

  &lt;!-- proxies
   | This is a list of proxies which can be used on this machine to connect to the network.
   | Unless otherwise specified (by system property or command-line switch), the first proxy
   | specification in this list marked as active will be used.
   |--&gt;
  &lt;proxies&gt;
    &lt;!-- proxy
     | Specification for one proxy, to be used in connecting to the network.
     |
    &lt;proxy&gt;
      &lt;id&gt;optional&lt;/id&gt;
      &lt;active&gt;true&lt;/active&gt;
      &lt;protocol&gt;http&lt;/protocol&gt;
      &lt;username&gt;proxyuser&lt;/username&gt;
      &lt;password&gt;proxypass&lt;/password&gt;
      &lt;host&gt;proxy.host.net&lt;/host&gt;
      &lt;port&gt;80&lt;/port&gt;
      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;
    &lt;/proxy&gt;
    --&gt;
  &lt;/proxies&gt;

  &lt;!-- servers
   | This is a list of authentication profiles, keyed by the server-id used within the system.
   | Authentication profiles can be used whenever maven must make a connection to a remote server.
   |--&gt;
  &lt;servers&gt;
    &lt;!-- server
     | Specifies the authentication information to use when connecting to a particular server, identified by
     | a unique name within the system (referred to by the &#39;id&#39; attribute below).
     |
     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are
     |       used together.
     |
    &lt;server&gt;
      &lt;id&gt;deploymentRepo&lt;/id&gt;
      &lt;username&gt;repouser&lt;/username&gt;
      &lt;password&gt;repopwd&lt;/password&gt;
    &lt;/server&gt;
    --&gt;

    &lt;!-- Another sample, using keys to authenticate.
    &lt;server&gt;
      &lt;id&gt;siteServer&lt;/id&gt;
      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;
      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;
    &lt;/server&gt;
    --&gt;
  &lt;/servers&gt;

  &lt;!-- mirrors
   | This is a list of mirrors to be used in downloading artifacts from remote repositories.
   |
   | It works like this: a POM may declare a repository to use in resolving certain artifacts.
   | However, this repository may have problems with heavy traffic at times, so people have mirrored
   | it to several places.
   |
   | That repository definition will have a unique id, so we can create a mirror reference for that
   | repository, to be used as an alternate download site. The mirror site will be the preferred
   | server for that repository.
   |--&gt;
  &lt;mirrors&gt;
    &lt;!-- mirror
     | Specifies a repository mirror site to use instead of a given repository. The repository that
     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
     |
    &lt;mirror&gt;
      &lt;id&gt;mirrorId&lt;/id&gt;
      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;
      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;
      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;
    &lt;/mirror&gt;
     --&gt;

    &lt;mirror&gt;
      &lt;id&gt;nexus-aliyun&lt;/id&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
      &lt;name&gt;Nexus aliyun&lt;/name&gt;
      &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt;
    &lt;/mirror&gt;

  &lt;/mirrors&gt;

  &lt;!-- profiles
   | This is a list of profiles which can be activated in a variety of ways, and which can modify
   | the build process. Profiles provided in the settings.xml are intended to provide local machine-
   | specific paths and repository locations which allow the build to work in the local environment.
   |
   | For example, if you have an integration testing plugin - like cactus - that needs to know where
   | your Tomcat instance is installed, you can provide a variable here such that the variable is
   | dereferenced during the build process to configure the cactus plugin.
   |
   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles
   | section of this document (settings.xml) - will be discussed later. Another way essentially
   | relies on the detection of a system property, either matching a particular value for the property,
   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a
   | value of &#39;1.4&#39; might activate a profile when the build is executed on a JDK version of &#39;1.4.2_07&#39;.
   | Finally, the list of active profiles can be specified directly from the command line.
   |
   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact
   |       repositories, plugin repositories, and free-form properties to be used as configuration
   |       variables for plugins in the POM.
   |
   |--&gt;
  &lt;profiles&gt;
    &lt;!-- profile
     | Specifies a set of introductions to the build process, to be activated using one or more of the
     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;
     | or the command line, profiles have to have an ID that is unique.
     |
     | An encouraged best practice for profile identification is to use a consistent naming convention
     | for profiles, such as &#39;env-dev&#39;, &#39;env-test&#39;, &#39;env-production&#39;, &#39;user-jdcasey&#39;, &#39;user-brett&#39;, etc.
     | This will make it more intuitive to understand what the set of introduced profiles is attempting
     | to accomplish, particularly when you only have a list of profile id&#39;s for debug.
     |
     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.
    &lt;profile&gt;
      &lt;id&gt;jdk-1.4&lt;/id&gt;

      &lt;activation&gt;
        &lt;jdk&gt;1.4&lt;/jdk&gt;
      &lt;/activation&gt;

      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;jdk14&lt;/id&gt;
          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;
          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;
          &lt;layout&gt;default&lt;/layout&gt;
          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
    &lt;/profile&gt;
    --&gt;

    &lt;!--
     | Here is another profile, activated by the system property &#39;target-env&#39; with a value of &#39;dev&#39;,
     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration
     | might hypothetically look like:
     |
     | ...
     | &lt;plugin&gt;
     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;
     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;
     |
     |   &lt;configuration&gt;
     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;
     |   &lt;/configuration&gt;
     | &lt;/plugin&gt;
     | ...
     |
     | NOTE: If you just wanted to inject this configuration whenever someone set &#39;target-env&#39; to
     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.
     |
    &lt;profile&gt;
      &lt;id&gt;env-dev&lt;/id&gt;

      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;target-env&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;

      &lt;properties&gt;
        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    --&gt;

     &lt;profile&gt;  
        &lt;id&gt;jdk-1.8&lt;/id&gt;  
        &lt;activation&gt;  
            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  
            &lt;jdk&gt;1.8&lt;/jdk&gt;  
        &lt;/activation&gt;  
        &lt;properties&gt;  
            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;  
            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;  
            &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  
        &lt;/properties&gt;  
    &lt;/profile&gt;


  &lt;/profiles&gt;

  &lt;!-- activeProfiles
   | List of profiles that are active for all builds.
   |
  &lt;activeProfiles&gt;
    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;
    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;
  &lt;/activeProfiles&gt;
  --&gt;

   &lt;activeProfiles&gt;
       &lt;activeProfile&gt;jdk-1.8&lt;/activeProfile&gt;
   &lt;/activeProfiles&gt;
&lt;/settings&gt;
</code></pre>
<h1 id="idea和maven关联"><a href="#idea和maven关联" class="headerlink" title="idea和maven关联"></a>idea和maven关联</h1><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p> <img src="/../imgs/assets03/1665476650558.png" alt="1665476650558"></p>
<h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p> <img src="/../imgs/assets03/1665476773949.png" alt="1665476773949"></p>
<h1 id="maven网址"><a href="#maven网址" class="headerlink" title="maven网址"></a>maven网址</h1><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<h1 id="创建SE项目步骤"><a href="#创建SE项目步骤" class="headerlink" title="创建SE项目步骤"></a>创建SE项目步骤</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ul>
<li>步骤一<br> <img src="/../imgs/assets03/1665478807736.png" alt="1665478807736"></li>
<li>步骤二<br> <img src="/../imgs/assets03/1665478873740.png" alt="1665478873740"></li>
<li>步骤三<br> <img src="/../imgs/assets03/1665478968465.png" alt="1665478968465"></li>
</ul>
<h1 id="创建WEB项目"><a href="#创建WEB项目" class="headerlink" title="创建WEB项目"></a>创建WEB项目</h1><ul>
<li><p>步骤一</p>
<p><img src="/../imgs/assets03/1665479190875.png" alt="1665479190875"></p>
</li>
<li><p>步骤二</p>
<p> <img src="/../imgs/assets03/1665479299423.png" alt="1665479299423"></p>
</li>
<li><p>步骤三</p>
<p><img src="/../imgs/assets03/1665479353127.png" alt="1665479353127"></p>
</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> <img src="/../imgs/assets03/1665480234205.png" alt="1665480234205"></p>
<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><ul>
<li><p>mvn clean</p>
<blockquote>
<p>编译的产物全部清空</p>
</blockquote>
</li>
<li><p>mvn compile</p>
<blockquote>
<p>编译</p>
</blockquote>
</li>
<li><p>mvn test</p>
<blockquote>
<p>执行单元测试</p>
</blockquote>
</li>
<li><p>mvn package</p>
<blockquote>
<p>打包</p>
</blockquote>
</li>
<li><p>mvn install</p>
<blockquote>
<p>打包+安装【将打包后的文件放入到本地仓库】</p>
</blockquote>
</li>
</ul>
<h1 id="tomcat插件"><a href="#tomcat插件" class="headerlink" title="tomcat插件"></a>tomcat插件</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="xml">&lt;build&gt;                                                         
    &lt;plugins&gt;                                                   
        &lt;!-- tomcat7 插件 --&gt;                                     
        &lt;plugin&gt;                                                
            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;          
            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;       
            &lt;version&gt;2.2&lt;/version&gt;                              
            &lt;configuration&gt;                                     
               &lt;!-- tomcat的端口 --&gt;                               
               &lt;port&gt;80&lt;/port&gt;                                  
               &lt;!-- 上下文路径 --&gt;                                   
               &lt;path&gt;/&lt;/path&gt;                                   
            &lt;/configuration&gt;                                    
        &lt;/plugin&gt;                                               
    &lt;/plugins&gt;                                                  
&lt;/build&gt;                                                        
</code></pre>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li><p>步骤一</p>
<p><img src="/../imgs/assets03/1688697995815.png" alt="1688697995815"></p>
</li>
<li><p>步骤二<br><img src="/../imgs/assets03/1688697593489.png" alt="1688697593489"></p>
</li>
<li><p>步骤三<br><img src="/../imgs/assets03/1688697622414.png" alt="1688697622414"></p>
</li>
</ul>
<h1 id="scope属性"><a href="#scope属性" class="headerlink" title="scope属性"></a>scope属性</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p>用来控制依赖的作用范围</p>
<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p> <img src="/../imgs/assets03/1688711450072.png" alt="1688711450072"></p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h2><ul>
<li>处理某一领域的最佳的解决方案</li>
<li>基于框架上实现我们的业务逻辑</li>
</ul>
<h2 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h2><ul>
<li>spring</li>
<li>springmvc</li>
<li>mybatis</li>
<li>springBoot</li>
<li>springCloud</li>
<li>等等</li>
</ul>
<h1 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h1><h2 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h2><ul>
<li>基于jdbc的ORM框架</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><p>添加依赖</p>
<ul>
<li>驱动</li>
<li>mybatis自己的依赖</li>
</ul>
</li>
<li><p>配置文件</p>
<ul>
<li>主配置文件<ul>
<li>数据库的连接信息</li>
<li>指定映射文件</li>
</ul>
</li>
<li>映射文件<ul>
<li>包含sql语句</li>
</ul>
</li>
</ul>
</li>
<li><p>写代码</p>
<ul>
<li>SqlSessionFactoryBuilder</li>
<li>SqlSessionFactory 【连接池】</li>
<li>SqlSession 【Connection】<ul>
<li>相关方法</li>
</ul>
</li>
<li>资源释放</li>
</ul>
</li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><ul>
<li><p>添加依赖</p>
<pre><code class="xml">&lt;!--mysql驱动--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;version&gt;8.0.28&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!--mybatis依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
   &lt;version&gt;3.5.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置文件</p>
<ul>
<li><p>主配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/examination&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;sdcx123456,&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!--指定映射文件【sql语句】--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li><p>映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;


&lt;mapper namespace=&quot;com.neu.mapper.UserMapper&quot;&gt;

    &lt;resultMap id=&quot;baseResultMap&quot; type=&quot;com.neu.vo.UserVO&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;user_name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;
    &lt;/resultMap&gt;

    &lt;!--查询全部员工信息--&gt;
    &lt;!--
      namespace+id要唯一
      resultType一行记录封装成什么类型的对象

      resultMap:用来描述列名和属性名的对应关系 user_name列名  name属性
    --&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;baseResultMap&quot;&gt;
        select * from t_user
    &lt;/select&gt;


    &lt;!--根据id查找数据--&gt;
    &lt;select id=&quot;findById&quot; resultMap=&quot;baseResultMap&quot;&gt;
        select * from t_user where id = #&#123;xx&#125;
    &lt;/select&gt;

    &lt;insert id=&quot;add&quot; parameterType=&quot;com.neu.domain.User&quot;&gt;
        insert into t_user(user_name,password,age) values(#&#123;name&#125;,#&#123;password&#125;,#&#123;age&#125;)
    &lt;/insert&gt;

    &lt;!--int？--&gt;
    &lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot; &gt;
        delete from t_user where id = #&#123;yy&#125;
    &lt;/delete&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.neu.domain.User&quot;&gt;
      update t_user set user_name=#&#123;name&#125;,password=#&#123;password&#125;,age=#&#123;age&#125; where id = #&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li><p>UserVO.java</p>
<pre><code class="java">public class UserVO &#123;

    private Integer id;
    private String name;
    private String password;
    private Integer age;

    public Integer getId() &#123;
        return id;
    &#125;

    public void setId(Integer id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getPassword() &#123;
        return password;
    &#125;

    public void setPassword(String password) &#123;
        this.password = password;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;

    public void setAge(Integer age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;UserVO&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>SqlSessionFactoryUtil.java</p>
<pre><code class="java">public class SqlSessionFactoryUtil &#123;

    private static SqlSessionFactory sqlSessionFactory;
    static&#123;
        InputStream inputStream = null;
        try &#123;
            inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);
            SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
            sqlSessionFactory = builder.build(inputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static SqlSession openSession()&#123;
        return sqlSessionFactory.openSession();
    &#125;
&#125;
</code></pre>
</li>
<li><p>CRUDTest.java</p>
<pre><code class="java">public class CRUDTest &#123;

    public static void main(String[] args) throws IOException &#123;


        //mybatis
            //添加依赖
            //编写配置文件
                //主配置文件
                //映射文件
            //代码
                //SqlSessionFactoryBuilder
                     //SqlSessionFactory[连接池]
                          //SqlSession[Connection对象]
                              //调用方法
                              //释放资源

        //findAll();

        //findById(5);

        User user = new User();
        user.setPassword(&quot;root&quot;);
        user.setAge(30);
        user.setName(&quot;zhangsan&quot;);

        //add(user);

        //deleteById(10);

        user.setId(5);
        update(user);
        findAll();
    &#125;

    /**
     * 查询全部
     * @throws IOException
     */
    public static void findAll() throws IOException &#123;
        /*
        InputStream inputStream =  Resources.getResourceAsStream(&quot;mybatis.xml&quot;);
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory = builder.build(inputStream);

        //Connection
        SqlSession sqlSession = sqlSessionFactory.openSession();
         */

        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();
        List&lt;UserVO&gt; dataList = sqlSession.selectList(&quot;com.neu.mapper.UserMapper.findAll&quot;);

        for(UserVO userVO:dataList)&#123;
            System.out.println(userVO);
        &#125;

        sqlSession.close();
    &#125;

    /**
     * 根据id查询
     * @param id
     */
    public static void findById(int id)&#123;
        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();
        //sqlSession.selectOne(&quot;sql的id&quot;,参数值);
        UserVO userVO = sqlSession.selectOne(&quot;com.neu.mapper.UserMapper.findById&quot;,id);

        System.out.println(userVO);
        sqlSession.close();
    &#125;

    public static void add(User user)&#123;
        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();
        //sqlSession.insert(&quot;sql的id&quot;,参数值);
        sqlSession.insert(&quot;com.neu.mapper.UserMapper.add&quot;,user);

        //dml操作
             //insert update delete 需要提交事务
        sqlSession.commit();

        sqlSession.close();
    &#125;

    public static void deleteById(int id)&#123;
        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();

        //sqlSession.delete(&quot;sql的id&quot;,参数);
        sqlSession.delete(&quot;com.neu.mapper.UserMapper.deleteById&quot;,id);
        sqlSession.commit();
        sqlSession.close();
    &#125;

    public static void update(User user)&#123;
        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();

        //sqlSession.update(&quot;sql的id&quot;,参数);
        sqlSession.update(&quot;com.neu.mapper.UserMapper.update&quot;,user);
        sqlSession.commit();
        sqlSession.close();
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h1><pre><code class="sql">SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `age` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (5, &#39;python&#39;, &#39;123&#39;, NULL);
INSERT INTO `t_user` VALUES (6, &#39;xxx&#39;, &#39;123&#39;, NULL);
INSERT INTO `t_user` VALUES (7, &#39;c++&#39;, &#39;123&#39;, NULL);
INSERT INTO `t_user` VALUES (8, &#39;php&#39;, &#39;123&#39;, NULL);

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>java实训</tag>
        <tag>DAY3</tag>
      </tags>
  </entry>
</search>
